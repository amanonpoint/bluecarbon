{
  "chunks": [
    {
      "text": "{0}------------------------------------------------  \nGareth James • Daniela Witten • Trevor Hastie Robert Tibshirani",
      "metadata": {
        "header": null,
        "subheader": null,
        "page": "0",
        "chunk_id": "chk_2e25ba96-98d7-4a0a-b585-57d8a6f80aa2",
        "chunk_size": 11,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# An Introduction to Statistical Learning  \nwith Applications in R  \n![](_page_0_Picture_3.jpeg)  \n{1}------------------------------------------------  \nGareth James Department of Information and Operations Management University of Southern California Los Angeles, CA, USA  \nTrevor Hastie Department of Statistics Stanford University Stanford, CA, USA  \nDaniela Witten Department of Biostatistics University of Washington Seattle, WA, USA  \nRobert Tibshirani Department of Statistics Stanford University Stanford, CA, USA  \nISSN 1431-875X ISBN 978-1-4614-7137-0 ISBN 978-1-4614-7138-7 (eBook) DOI 10.1007/978-1-4614-7138-7 Springer New York Heidelberg Dordrecht London  \nLibrary of Congress Control Number: 2013936251  \n© Springer Science+Business Media New York 2013 (Corrected at 6th printing 2015)  \nThis work is subject to copyright. All rights are reserved by the Publisher, whether the whole or part of the material is concerned, specifically the rights of translation, reprinting, reuse of illustrations, recitation, broadcasting, reproduction on microfilms or in any other physical way, and transmission or information storage and retrieval, electronic adaptation, computer software, or by similar or dissimilar methodology now known or hereafter developed. Exempted from this legal reservation are brief excerpts in connection with reviews or scholarly analysis or material supplied specifically for the purpose of being entered and executed on a computer system, for exclusive use by the purchaser of the work. Duplication of this publication or parts thereof is permitted only under the provisions of the Copyright Law of the Publisher's location, in its current version, and permission for use must always be obtained from Springer. Permissions for use may be obtained through RightsLink at the Copyright Clearance Center. Violations are liable to prosecution under the respective Copyright Law.  \nThe use of general descriptive names, registered names, trademarks, service marks, etc. in this publication does not imply, even in the absence of a specific statement, that such names are exempt from the relevant protective laws and regulations and therefore free for general use.  \nWhile the advice and information in this book are believed to be true and accurate at the date of publication, neither the authors nor the editors nor the publisher can accept any legal responsibility for any errors or omissions that may be made. The publisher makes no warranty, express or implied, with respect to the material contained herein.  \nPrinted on acid-free paper  \nSpringer is part of Springer Science+Business Media (www.springer.com)  \n{2}------------------------------------------------",
      "metadata": {
        "header": "An Introduction to Statistical Learning",
        "subheader": null,
        "page": "0-2",
        "chunk_id": "chk_b5affe3d-b55e-40dc-875e-ebe08ff86296",
        "chunk_size": 370,
        "chunk_img_path": "_page_0_Picture_3.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_0_Picture_3.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### To our parents:  \nAlison and Michael James Chiara Nappi and Edward Witten Valerie and Patrick Hastie Vera and Sami Tibshirani  \nand to our families:  \nMichael, Daniel, and Catherine Tessa and Ari Samantha, Timothy, and Lynda Charlie, Ryan, Julie, and Cheryl  \n{3}------------------------------------------------  \n{4}------------------------------------------------",
      "metadata": {
        "header": "An Introduction to Statistical Learning",
        "subheader": "To our parents:",
        "page": "2-4",
        "chunk_id": "chk_2872fd62-3a70-4c95-9fa5-ca72c6c6f5e8",
        "chunk_size": 43,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# Preface  \nStatistical learning refers to a set of tools for modeling and understanding complex datasets. It is a recently developed area in statistics and blends with parallel developments in computer science and, in particular, machine learning. The field encompasses many methods such as the lasso and sparse regression, classification and regression trees, and boosting and support vector machines.  \nWith the explosion of \"Big Data\" problems, statistical learning has become a very hot field in many scientific areas as well as marketing, finance, and other business disciplines. People with statistical learning skills are in high demand.  \nOne of the first books in this area—*The Elements of Statistical Learning* (ESL) (Hastie, Tibshirani, and Friedman)—was published in 2001, with a second edition in 2009. ESL has become a popular text not only in statistics but also in related fields. One of the reasons for ESL's popularity is its relatively accessible style. But ESL is intended for individuals with advanced training in the mathematical sciences. *An Introduction to Statistical Learning* (ISL) arose from the perceived need for a broader and less technical treatment of these topics. In this new book, we cover many of the same topics as ESL, but we concentrate more on the applications of the methods and less on the mathematical details. We have created labs illustrating how to implement each of the statistical learning methods using the popular statistical software package R. These labs provide the reader with valuable hands-on experience.  \nThis book is appropriate for advanced undergraduates or master's students in statistics or related quantitative fields or for individuals in other  \n{5}------------------------------------------------  \ndisciplines who wish to use statistical learning tools to analyze their data. It can be used as a textbook for a course spanning one or two semesters.  \nWe would like to thank several readers for valuable comments on preliminary drafts of this book: Pallavi Basu, Alexandra Chouldechova, Patrick Danaher, Will Fithian, Luella Fu, Sam Gross, Max Grazier G'Sell, Courtney Paulson, Xinghao Qiao, Elisa Sheng, Noah Simon, Kean Ming Tan, and Xin Lu Tan.  \n*It's tough to make predictions, especially about the future.*  \n-Yogi Berra  \nPalo Alto, USA Robert Tibshirani  \nLos Angeles, USA Gareth James Seattle, USA Daniela Witten Palo Alto, USA Trevor Hastie  \n{6}------------------------------------------------",
      "metadata": {
        "header": "Preface",
        "subheader": null,
        "page": "4-6",
        "chunk_id": "chk_55fb08c4-ff7b-4255-ba7d-c498ed5bbc18",
        "chunk_size": 368,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# Contents  \n|   | Preface                 |              |                                                          | vii |\n|---|-------------------------|--------------|----------------------------------------------------------|-----|\n| 1 |                         | Introduction |                                                          | 1   |\n| 2 | Statistical<br>Learning |              | 15                                                       |     |\n|   | 2.1                     | What         | Is<br>Statistical<br>Learning?                           | 15  |\n|   |                         | 2.1.1        | Why<br>Estimate<br>f?                                    | 17  |\n|   |                         | 2.1.2        | How<br>Do<br>We<br>Estimate<br>f?                        | 21  |\n|   |                         | 2.1.3        | The<br>Trade-Off<br>Between<br>Prediction<br>Accuracy    |     |\n|   |                         |              | and<br>Model<br>Interpretability                         | 24  |\n|   |                         | 2.1.4        | Supervised<br>Versus<br>Unsupervised<br>Learning         | 26  |\n|   |                         | 2.1.5        | Regression<br>Versus<br>Classification<br>Problems       | 28  |\n|   | 2.2                     | Assessing    | Model<br>Accuracy                                        | 29  |\n|   |                         | 2.2.1        | Measuring<br>the<br>Quality<br>of<br>Fit                 | 29  |\n|   |                         | 2.2.2        | The<br>Bias-Variance<br>Trade-Off                        | 33  |\n|   |                         | 2.2.3        | The<br>Classification<br>Setting                         | 37  |\n|   | 2.3                     | Lab:         | Introduction<br>to<br>R                                  | 42  |\n|   |                         | 2.3.1        | Basic<br>Commands                                        | 42  |\n|   |                         | 2.3.2        | Graphics                                                 | 45  |\n|   |                         | 2.3.3        | Indexing<br>Data                                         | 47  |\n|   |                         | 2.3.4        | Loading<br>Data                                          | 48  |\n|   |                         | 2.3.5        | Additional<br>Graphical<br>and<br>Numerical<br>Summaries | 49  |\n|   | 2.4                     | Exercises    |                                                          | 52  |  \n{7}------------------------------------------------  \n| 3 | Linear | Regression                                                          | 59  |\n|---|--------|---------------------------------------------------------------------|-----|\n|   | 3.1    | Simple<br>Linear<br>Regression                                      | 61  |\n|   |        | 3.1.1<br>Estimating<br>the<br>Coefficients                          | 61  |\n|   |        | 3.1.2<br>Assessing<br>the<br>Accuracy<br>of<br>the<br>Coefficient   |     |\n|   |        | Estimates                                                           | 63  |\n|   |        | 3.1.3<br>Assessing<br>the<br>Accuracy<br>of<br>the<br>Model         | 68  |\n|   | 3.2    | Multiple<br>Linear<br>Regression                                    | 71  |\n|   |        | 3.2.1<br>Estimating<br>the<br>Regression<br>Coefficients            | 72  |\n|   |        | 3.2.2<br>Some<br>Important<br>Questions                             | 75  |\n|   | 3.3    | Other<br>Considerations<br>in<br>the<br>Regression<br>Model         | 82  |\n|   |        | 3.3.1<br>Qualitative<br>Predictors                                  | 82  |\n|   |        | 3.3.2<br>Extensions<br>of<br>the<br>Linear<br>Model                 | 86  |\n|   |        | 3.3.3<br>Potential<br>Problems                                      | 92  |\n|   | 3.4    | The<br>Marketing<br>Plan                                            | 102 |\n|   | 3.5    | Comparison<br>of<br>Linear<br>Regression<br>with<br>K-Nearest       |     |\n|   |        | Neighbors                                                           | 104 |\n|   | 3.6    | Lab:<br>Linear<br>Regression                                        | 109 |\n|   |        | 3.6.1<br>Libraries                                                  | 109 |\n|   |        | 3.6.2<br>Simple<br>Linear<br>Regression                             | 110 |\n|   |        | 3.6.3<br>Multiple<br>Linear<br>Regression                           | 113 |\n|   |        | 3.6.4<br>Interaction<br>Terms                                       | 115 |\n|   |        | 3.6.5<br>Non-linear<br>Transformations<br>of<br>the<br>Predictors   | 115 |\n|   |        | 3.6.6<br>Qualitative<br>Predictors                                  | 117 |\n|   |        | 3.6.7<br>Writing<br>Functions                                       | 119 |\n|   | 3.7    | Exercises                                                           | 120 |\n| 4 |        | Classification                                                      | 127 |\n|   | 4.1    | An<br>Overview<br>of<br>Classification                              | 128 |\n|   | 4.2    | Why<br>Not<br>Linear<br>Regression?                                 | 129 |\n|   | 4.3    | Logistic<br>Regression                                              | 130 |\n|   |        | 4.3.1<br>The<br>Logistic<br>Model                                   | 131 |\n|   |        | 4.3.2<br>Estimating<br>the<br>Regression<br>Coefficients            | 133 |\n|   |        | 4.3.3<br>Making<br>Predictions                                      | 134 |\n|   |        | 4.3.4<br>Multiple<br>Logistic<br>Regression                         | 135 |\n|   |        | 4.3.5<br>Logistic<br>Regression<br>for<br>>2<br>Response<br>Classes | 137 |\n|   |        |                                                                     |     |\n|   | 4.4    | Linear<br>Discriminant<br>Analysis                                  | 138 |\n|   |        | 4.4.1<br>Using<br>Bayes'<br>Theorem<br>for<br>Classification        | 138 |\n|   |        | 4.4.2<br>Linear<br>Discriminant<br>Analysis<br>for<br>p<br>=<br>1   | 139 |\n|   |        | 4.4.3<br>Linear<br>Discriminant<br>Analysis<br>for<br>p<br>>1       | 142 |\n|   |        | 4.4.4<br>Quadratic<br>Discriminant<br>Analysis                      | 149 |\n|   | 4.5    | A<br>Comparison<br>of<br>Classification<br>Methods                  | 151 |\n|   | 4.6    | Lab:<br>Logistic<br>Regression,<br>LDA,<br>QDA,<br>and<br>KNN       | 154 |\n|   |        | 4.6.1<br>The<br>Stock<br>Market<br>Data                             | 154 |\n|   |        | 4.6.2<br>Logistic<br>Regression                                     | 156 |\n|   |        | 4.6.3<br>Linear<br>Discriminant<br>Analysis                         | 161 |  \n{8}------------------------------------------------  \n|   |        | 4.6.4              | Quadratic<br>Discriminant<br>Analysis                     | 163        |\n|---|--------|--------------------|-----------------------------------------------------------|------------|\n|   |        | 4.6.5              | K-Nearest<br>Neighbors                                    | 163        |\n|   | 4.7    | 4.6.6<br>Exercises | An<br>Application<br>to<br>Caravan<br>Insurance<br>Data   | 165<br>168 |\n|   |        |                    |                                                           |            |\n| 5 |        | Resampling         | Methods                                                   | 175        |\n|   | 5.1    |                    | Cross-Validation                                          | 176        |\n|   |        | 5.1.1              | The<br>Validation<br>Set<br>Approach                      | 176        |\n|   |        | 5.1.2              | Leave-One-Out<br>Cross-Validation                         | 178        |\n|   |        | 5.1.3              | k-Fold<br>Cross-Validation                                | 181        |\n|   |        | 5.1.4              | Bias-Variance<br>Trade-Off<br>for<br>k-Fold               |            |\n|   |        |                    | Cross-Validation                                          | 183        |\n|   |        | 5.1.5              | Cross-Validation<br>on<br>Classification<br>Problems      | 184        |\n|   | 5.2    | The                | Bootstrap                                                 | 187        |\n|   | 5.3    | Lab:               | Cross-Validation<br>and<br>the<br>Bootstrap               | 190        |\n|   |        | 5.3.1              | The<br>Validation<br>Set<br>Approach                      | 191        |\n|   |        | 5.3.2              | Leave-One-Out<br>Cross-Validation                         | 192        |\n|   |        | 5.3.3              | k-Fold<br>Cross-Validation                                | 193        |\n|   |        | 5.3.4              | The<br>Bootstrap                                          | 194        |\n|   | 5.4    | Exercises          |                                                           | 197        |\n|   |        |                    |                                                           |            |\n| 6 | Linear |                    | Model<br>Selection<br>and<br>Regularization               | 203        |\n|   | 6.1    | Subset             | Selection                                                 | 205        |\n|   |        | 6.1.1              | Best<br>Subset<br>Selection                               | 205        |\n|   |        | 6.1.2              | Stepwise<br>Selection                                     | 207        |\n|   |        | 6.1.3              | Choosing<br>the<br>Optimal<br>Model                       | 210        |\n|   | 6.2    | Shrinkage          | Methods                                                   | 214        |\n|   |        | 6.2.1              | Ridge<br>Regression                                       | 215        |\n|   |        | 6.2.2              | The<br>Lasso                                              | 219        |\n|   |        | 6.2.3              | Selecting<br>the<br>Tuning<br>Parameter                   | 227        |\n|   | 6.3    | Dimension          | Reduction<br>Methods                                      | 228        |\n|   |        | 6.3.1              | Principal<br>Components<br>Regression                     | 230        |\n|   |        | 6.3.2              | Partial<br>Least<br>Squares                               | 237        |\n|   | 6.4    |                    | Considerations<br>in<br>High<br>Dimensions                | 238        |\n|   |        | 6.4.1              | High-Dimensional<br>Data                                  | 238        |\n|   |        | 6.4.2              | What<br>Goes<br>Wrong<br>in<br>High<br>Dimensions?        | 239        |\n|   |        | 6.4.3              | Regression<br>in<br>High<br>Dimensions                    | 241        |\n|   |        | 6.4.4              | Interpreting<br>Results<br>in<br>High<br>Dimensions       | 243        |\n|   | 6.5    | Lab<br>1:          | Subset<br>Selection<br>Methods                            | 244        |\n|   |        | 6.5.1              | Best<br>Subset<br>Selection                               | 244        |\n|   |        | 6.5.2              | Forward<br>and<br>Backward<br>Stepwise<br>Selection       | 247        |\n|   |        | 6.5.3              | Choosing<br>Among<br>Models<br>Using<br>the<br>Validation |            |\n|   |        |                    | Set<br>Approach<br>and<br>Cross-Validation                | 248        |  \n{9}------------------------------------------------  \n|   | 6.6 | Lab<br>2:<br>Ridge<br>Regression<br>and<br>the<br>Lasso       | 251 |\n|---|-----|---------------------------------------------------------------|-----|\n|   |     | 6.6.1<br>Ridge<br>Regression                                  | 251 |\n|   |     | 6.6.2<br>The<br>Lasso                                         | 255 |\n|   | 6.7 | Lab<br>3:<br>PCR<br>and<br>PLS<br>Regression                  | 256 |\n|   |     | 6.7.1<br>Principal<br>Components<br>Regression                | 256 |\n|   |     | 6.7.2<br>Partial<br>Least<br>Squares                          | 258 |\n|   | 6.8 | Exercises                                                     | 259 |\n| 7 |     | Moving<br>Beyond<br>Linearity                                 | 265 |\n|   | 7.1 | Polynomial<br>Regression                                      | 266 |\n|   | 7.2 | Step<br>Functions                                             | 268 |\n|   | 7.3 | Basis<br>Functions                                            | 270 |\n|   | 7.4 | Regression<br>Splines                                         | 271 |\n|   |     | 7.4.1<br>Piecewise<br>Polynomials                             | 271 |\n|   |     | 7.4.2<br>Constraints<br>and<br>Splines                        | 271 |\n|   |     | 7.4.3<br>The<br>Spline<br>Basis<br>Representation             | 273 |\n|   |     | 7.4.4<br>Choosing<br>the<br>Number<br>and<br>Locations        |     |\n|   |     | of<br>the<br>Knots                                            | 274 |\n|   |     | 7.4.5<br>Comparison<br>to<br>Polynomial<br>Regression         | 276 |\n|   | 7.5 | Smoothing<br>Splines                                          | 277 |\n|   |     | 7.5.1<br>An<br>Overview<br>of<br>Smoothing<br>Splines         | 277 |\n|   |     |                                                               |     |\n|   |     | 7.5.2<br>Choosing<br>the<br>Smoothing<br>Parameter<br>λ       | 278 |\n|   | 7.6 | Local<br>Regression                                           | 280 |\n|   | 7.7 | Generalized<br>Additive<br>Models                             | 282 |\n|   |     | 7.7.1<br>GAMs<br>for<br>Regression<br>Problems                | 283 |\n|   |     | 7.7.2<br>GAMs<br>for<br>Classification<br>Problems            | 286 |\n|   | 7.8 | Lab:<br>Non-linear<br>Modeling                                | 287 |\n|   |     | 7.8.1<br>Polynomial<br>Regression<br>and<br>Step<br>Functions | 288 |\n|   |     | 7.8.2<br>Splines                                              | 293 |\n|   |     | 7.8.3<br>GAMs                                                 | 294 |\n|   | 7.9 | Exercises                                                     | 297 |\n| 8 |     | Tree-Based<br>Methods                                         | 303 |\n|   | 8.1 | The<br>Basics<br>of<br>Decision<br>Trees                      | 303 |\n|   |     | 8.1.1<br>Regression<br>Trees                                  | 304 |\n|   |     | 8.1.2<br>Classification<br>Trees                              | 311 |\n|   |     | 8.1.3<br>Trees<br>Versus<br>Linear<br>Models                  | 314 |\n|   |     | 8.1.4<br>Advantages<br>and<br>Disadvantages<br>of<br>Trees    | 315 |\n|   | 8.2 | Bagging,<br>Random<br>Forests,<br>Boosting                    | 316 |\n|   |     | 8.2.1<br>Bagging                                              | 316 |\n|   |     | 8.2.2<br>Random<br>Forests                                    | 319 |\n|   |     | 8.2.3<br>Boosting                                             | 321 |\n|   | 8.3 | Lab:<br>Decision<br>Trees                                     | 323 |\n|   |     | 8.3.1<br>Fitting<br>Classification<br>Trees                   | 323 |\n|   |     | 8.3.2<br>Fitting<br>Regression<br>Trees                       | 327 |\n|   |     |                                                               |     |  \n{10}------------------------------------------------  \n|    |      | Contents                                                              | xiii |\n|----|------|-----------------------------------------------------------------------|------|\n|    |      | 8.3.3<br>Bagging<br>and<br>Random<br>Forests                          | 328  |\n|    |      | 8.3.4<br>Boosting                                                     | 330  |\n|    | 8.4  | Exercises                                                             | 332  |\n| 9  |      | Support<br>Vector<br>Machines                                         | 337  |\n|    | 9.1  | Maximal<br>Margin<br>Classifier                                       | 338  |\n|    |      | 9.1.1<br>What<br>Is<br>a<br>Hyperplane?                               | 338  |\n|    |      | 9.1.2<br>Classification<br>Using<br>a<br>Separating<br>Hyperplane     | 339  |\n|    |      | 9.1.3<br>The<br>Maximal<br>Margin<br>Classifier                       | 341  |\n|    |      | 9.1.4<br>Construction<br>of<br>the<br>Maximal<br>Margin<br>Classifier | 342  |\n|    |      | 9.1.5<br>The<br>Non-separable<br>Case                                 | 343  |\n|    | 9.2  | Support<br>Vector<br>Classifiers                                      | 344  |\n|    |      | 9.2.1<br>Overview<br>of<br>the<br>Support<br>Vector<br>Classifier     | 344  |\n|    |      | 9.2.2<br>Details<br>of<br>the<br>Support<br>Vector<br>Classifier      | 345  |\n|    | 9.3  | Support<br>Vector<br>Machines                                         | 349  |\n|    |      | 9.3.1<br>Classification<br>with<br>Non-linear<br>Decision             |      |\n|    |      | Boundaries                                                            | 349  |\n|    |      | 9.3.2<br>The<br>Support<br>Vector<br>Machine                          | 350  |\n|    |      | 9.3.3<br>An<br>Application<br>to<br>the<br>Heart<br>Disease<br>Data   | 354  |\n|    | 9.4  | SVMs<br>with<br>More<br>than<br>Two<br>Classes                        | 355  |\n|    |      | 9.4.1<br>One-Versus-One<br>Classification                             | 355  |\n|    |      | 9.4.2<br>One-Versus-All<br>Classification                             | 356  |\n|    | 9.5  | Relationship<br>to<br>Logistic<br>Regression                          | 356  |\n|    | 9.6  | Lab:<br>Support<br>Vector<br>Machines                                 | 359  |\n|    |      | 9.6.1<br>Support<br>Vector<br>Classifier                              | 359  |\n|    |      | 9.6.2<br>Support<br>Vector<br>Machine                                 | 363  |\n|    |      | 9.6.3<br>ROC<br>Curves                                                | 365  |\n|    |      | 9.6.4<br>SVM<br>with<br>Multiple<br>Classes                           | 366  |\n|    |      | 9.6.5<br>Application<br>to<br>Gene<br>Expression<br>Data              | 366  |\n|    | 9.7  | Exercises                                                             | 368  |\n| 10 |      | Unsupervised<br>Learning                                              | 373  |\n|    | 10.1 | The<br>Challenge<br>of<br>Unsupervised<br>Learning                    | 373  |\n|    | 10.2 | Principal<br>Components<br>Analysis                                   | 374  |\n|    |      | 10.2.1<br>What<br>Are<br>Principal<br>Components?                     | 375  |\n|    |      | 10.2.2<br>Another<br>Interpretation<br>of<br>Principal<br>Components  | 379  |\n|    |      | 10.2.3<br>More<br>on<br>PCA                                           | 380  |\n|    |      | 10.2.4<br>Other<br>Uses<br>for<br>Principal<br>Components             | 385  |\n|    | 10.3 | Clustering<br>Methods                                                 | 385  |\n|    |      | 10.3.1<br>K-Means<br>Clustering                                       | 386  |\n|    |      | 10.3.2<br>Hierarchical<br>Clustering                                  | 390  |\n|    |      | 10.3.3<br>Practical<br>Issues<br>in<br>Clustering                     | 399  |\n|    | 10.4 | Lab<br>1:<br>Principal<br>Components<br>Analysis                      | 401  |  \n{11}------------------------------------------------",
      "metadata": {
        "header": "Contents",
        "subheader": null,
        "page": "6-11",
        "chunk_id": "chk_0c3b517a-63d9-486c-98bb-eb70574b5d95",
        "chunk_size": 1539,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### xiv Contents  \n| Index |                                                                           | 419 |\n|-------|---------------------------------------------------------------------------|-----|\n| 10.7  | Exercises                                                                 | 413 |\n|       | 10.6.2<br>Clustering<br>the<br>Observations<br>of<br>the<br>NCI60<br>Data | 410 |\n|       | 10.6.1<br>PCA<br>on<br>the<br>NCI60<br>Data                               | 408 |\n| 10.6  | Lab<br>3:<br>NCI60<br>Data<br>Example                                     | 407 |\n|       | 10.5.2<br>Hierarchical<br>Clustering                                      | 406 |\n|       | 10.5.1<br>K-Means<br>Clustering                                           | 404 |\n| 10.5  | Lab<br>2:<br>Clustering                                                   | 404 |  \n{12}------------------------------------------------",
      "metadata": {
        "header": "Contents",
        "subheader": "xiv Contents",
        "page": "11-12",
        "chunk_id": "chk_25d6f3e1-60d0-4913-a455-c5ab9eeb5d77",
        "chunk_size": 56,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# 1",
      "metadata": {
        "header": "1",
        "subheader": null,
        "page": "12",
        "chunk_id": "chk_09207980-858f-4c28-ab87-84c45fe02c84",
        "chunk_size": 2,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# Introduction  \n#### An Overview of Statistical Learning  \n*Statistical learning* refers to a vast set of tools for *understanding data*. These tools can be classified as *supervised* or *unsupervised*. Broadly speaking, supervised statistical learning involves building a statistical model for predicting, or estimating, an *output* based on one or more *inputs*. Problems of this nature occur in fields as diverse as business, medicine, astrophysics, and public policy. With unsupervised statistical learning, there are inputs but no supervising output; nevertheless we can learn relationships and structure from such data. To provide an illustration of some applications of statistical learning, we briefly discuss three real-world data sets that are considered in this book.",
      "metadata": {
        "header": "Introduction",
        "subheader": "An Overview of Statistical Learning",
        "page": "12",
        "chunk_id": "chk_df3e6d63-5ed4-4c84-86f9-e4fcf1b37fa4",
        "chunk_size": 111,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Wage Data  \nIn this application (which we refer to as the Wage data set throughout this book), we examine a number of factors that relate to wages for a group of males from the Atlantic region of the United States. In particular, we wish to understand the association between an employee's age and education, as well as the calendar year, on his wage. Consider, for example, the left-hand panel of Figure 1.1, which displays wage versus age for each of the individuals in the data set. There is evidence that wage increases with age but then decreases again after approximately age 60. The blue line, which provides an estimate of the average wage for a given age, makes this trend clearer.  \n{13}------------------------------------------------  \n![](_page_13_Figure_2.jpeg)  \n**FIGURE 1.1.** Wage data, which contains income survey information for males from the central Atlantic region of the United States. Left: wage as a function of age. On average, wage increases with age until about 60 years of age, at which point it begins to decline. Center: wage as a function of year. There is a slow but steady increase of approximately \\$10,000 in the average wage between 2003 and 2009. Right: Boxplots displaying wage as a function of education, with 1 indicating the lowest level (no high school diploma) and 5 the highest level (an advanced graduate degree). On average, wage increases with the level of education.  \nGiven an employee's age, we can use this curve to *predict* his wage. However, it is also clear from Figure 1.1 that there is a significant amount of variability associated with this average value, and so age alone is unlikely to provide an accurate prediction of a particular man's wage.  \nWe also have information regarding each employee's education level and the year in which the wage was earned. The center and right-hand panels of Figure 1.1, which display wage as a function of both year and education, indicate that both of these factors are associated with wage. Wages increase by approximately \\$10,000, in a roughly linear (or straight-line) fashion, between 2003 and 2009, though this rise is very slight relative to the variability in the data. Wages are also typically greater for individuals with higher education levels: men with the lowest education level (1) tend to have substantially lower wages than those with the highest education level (5). Clearly, the most accurate prediction of a given man's wage will be obtained by combining his age, his education, and the year. In Chapter 3, we discuss linear regression, which can be used to predict wage from this data set. Ideally, we should predict wage in a way that accounts for the non-linear relationship between wage and age. In Chapter 7, we discuss a class of approaches for addressing this problem.",
      "metadata": {
        "header": "Introduction",
        "subheader": "Wage Data",
        "page": "12-13",
        "chunk_id": "chk_29d1d469-bf5f-4c41-ad13-49c910dbbe38",
        "chunk_size": 461,
        "chunk_img_path": "_page_13_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_13_Figure_2.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Stock Market Data  \nThe Wage data involves predicting a *continuous* or *quantitative* output value. This is often referred to as a *regression* problem. However, in certain cases we may instead wish to predict a non-numerical value—that is, a *categorical*  \n{14}------------------------------------------------  \n![](_page_14_Figure_2.jpeg)  \n**FIGURE 1.2.** Left: Boxplots of the previous day's percentage change in the S&P index for the days for which the market increased or decreased, obtained from the Smarket data. Center and Right: Same as left panel, but the percentage changes for 2 and 3 days previous are shown.  \nor *qualitative* output. For example, in Chapter 4 we examine a stock market data set that contains the daily movements in the Standard & Poor's 500 (S&P) stock index over a 5-year period between 2001 and 2005. We refer to this as the Smarket data. The goal is to predict whether the index will *increase* or *decrease* on a given day using the past 5 days' percentage changes in the index. Here the statistical learning problem does not involve predicting a numerical value. Instead it involves predicting whether a given day's stock market performance will fall into the Up bucket or the Down bucket. This is known as a *classification* problem. A model that could accurately predict the direction in which the market will move would be very useful!  \nThe left-hand panel of Figure 1.2 displays two boxplots of the previous day's percentage changes in the stock index: one for the 648 days for which the market increased on the subsequent day, and one for the 602 days for which the market decreased. The two plots look almost identical, suggesting that there is no simple strategy for using yesterday's movement in the S&P to predict today's returns. The remaining panels, which display boxplots for the percentage changes 2 and 3 days previous to today, similarly indicate little association between past and present returns. Of course, this lack of pattern is to be expected: in the presence of strong correlations between successive days' returns, one could adopt a simple trading strategy to generate profits from the market. Nevertheless, in Chapter 4, we explore these data using several different statistical learning methods. Interestingly, there are hints of some weak trends in the data that suggest that, at least for this 5-year period, it is possible to correctly predict the direction of movement in the market approximately 60% of the time (Figure 1.3).  \n{15}------------------------------------------------",
      "metadata": {
        "header": "Introduction",
        "subheader": "Stock Market Data",
        "page": "13-15",
        "chunk_id": "chk_f176a93a-0e7a-48ae-baa8-108ff207dbe8",
        "chunk_size": 401,
        "chunk_img_path": "_page_14_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_14_Figure_2.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### 4 1. Introduction  \n![](_page_15_Figure_1.jpeg)  \n**FIGURE 1.3.** We fit a quadratic discriminant analysis model to the subset of the Smarket data corresponding to the 2001–2004 time period, and predicted the probability of a stock market decrease using the 2005 data. On average, the predicted probability of decrease is higher for the days in which the market does decrease. Based on these results, we are able to correctly predict the direction of movement in the market 60% of the time.",
      "metadata": {
        "header": "Introduction",
        "subheader": "4 1. Introduction",
        "page": "15",
        "chunk_id": "chk_d95acb45-cfc4-4844-bc4f-5d34c336b672",
        "chunk_size": 79,
        "chunk_img_path": "_page_15_Figure_1.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_15_Figure_1.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Gene Expression Data  \nThe previous two applications illustrate data sets with both input and output variables. However, another important class of problems involves situations in which we only observe input variables, with no corresponding output. For example, in a marketing setting, we might have demographic information for a number of current or potential customers. We may wish to understand which types of customers are similar to each other by grouping individuals according to their observed characteristics. This is known as a *clustering* problem. Unlike in the previous examples, here we are not trying to predict an output variable.  \nWe devote Chapter 10 to a discussion of statistical learning methods for problems in which no natural output variable is available. We consider the NCI60 data set, which consists of 6,830 gene expression measurements for each of 64 cancer cell lines. Instead of predicting a particular output variable, we are interested in determining whether there are groups, or clusters, among the cell lines based on their gene expression measurements. This is a difficult question to address, in part because there are thousands of gene expression measurements per cell line, making it hard to visualize the data.  \nThe left-hand panel of Figure 1.4 addresses this problem by representing each of the 64 cell lines using just two numbers, Z<sup>1</sup> and Z2. These are the first two *principal components* of the data, which summarize the 6, 830 expression measurements for each cell line down to two numbers or *dimensions*. While it is likely that this dimension reduction has resulted in  \n{16}------------------------------------------------  \n![](_page_16_Figure_2.jpeg)  \n**FIGURE 1.4.** Left: Representation of the NCI60 gene expression data set in a two-dimensional space, Z<sup>1</sup> and Z2. Each point corresponds to one of the 64 cell lines. There appear to be four groups of cell lines, which we have represented using different colors. Right: Same as left panel except that we have represented each of the 14 different types of cancer using a different colored symbol. Cell lines corresponding to the same cancer type tend to be nearby in the two-dimensional space.  \nsome loss of information, it is now possible to visually examine the data for evidence of clustering. Deciding on the number of clusters is often a difficult problem. But the left-hand panel of Figure 1.4 suggests at least four groups of cell lines, which we have represented using separate colors. We can now examine the cell lines within each cluster for similarities in their types of cancer, in order to better understand the relationship between gene expression levels and cancer.  \nIn this particular data set, it turns out that the cell lines correspond to 14 different types of cancer. (However, this information was not used to create the left-hand panel of Figure 1.4.) The right-hand panel of Figure 1.4 is identical to the left-hand panel, except that the 14 cancer types are shown using distinct colored symbols. There is clear evidence that cell lines with the same cancer type tend to be located near each other in this two-dimensional representation. In addition, even though the cancer information was not used to produce the left-hand panel, the clustering obtained does bear some resemblance to some of the actual cancer types observed in the right-hand panel. This provides some independent verification of the accuracy of our clustering analysis.",
      "metadata": {
        "header": "Introduction",
        "subheader": "Gene Expression Data",
        "page": "15-16",
        "chunk_id": "chk_58bf1b34-8708-4985-9346-26c1bb1d37f3",
        "chunk_size": 548,
        "chunk_img_path": "_page_16_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_16_Figure_2.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### A Brief History of Statistical Learning  \nThough the term *statistical learning* is fairly new, many of the concepts that underlie the field were developed long ago. At the beginning of the nineteenth century, Legendre and Gauss published papers on the *method*  \n{17}------------------------------------------------  \n*of least squares*, which implemented the earliest form of what is now known as *linear regression*. The approach was first successfully applied to problems in astronomy. Linear regression is used for predicting quantitative values, such as an individual's salary. In order to predict qualitative values, such as whether a patient survives or dies, or whether the stock market increases or decreases, Fisher proposed *linear discriminant analysis* in 1936. In the 1940s, various authors put forth an alternative approach, *logistic regression*. In the early 1970s, Nelder and Wedderburn coined the term *generalized linear models* for an entire class of statistical learning methods that include both linear and logistic regression as special cases.  \nBy the end of the 1970s, many more techniques for learning from data were available. However, they were almost exclusively *linear* methods, because fitting *non-linear* relationships was computationally infeasible at the time. By the 1980s, computing technology had finally improved sufficiently that non-linear methods were no longer computationally prohibitive. In mid 1980s Breiman, Friedman, Olshen and Stone introduced *classification and regression trees*, and were among the first to demonstrate the power of a detailed practical implementation of a method, including cross-validation for model selection. Hastie and Tibshirani coined the term *generalized additive models* in 1986 for a class of non-linear extensions to generalized linear models, and also provided a practical software implementation.  \nSince that time, inspired by the advent of *machine learning* and other disciplines, statistical learning has emerged as a new subfield in statistics, focused on supervised and unsupervised modeling and prediction. In recent years, progress in statistical learning has been marked by the increasing availability of powerful and relatively user-friendly software, such as the popular and freely available R system. This has the potential to continue the transformation of the field from a set of techniques used and developed by statisticians and computer scientists to an essential toolkit for a much broader community.",
      "metadata": {
        "header": "Introduction",
        "subheader": "A Brief History of Statistical Learning",
        "page": "16-17",
        "chunk_id": "chk_509375ac-7c18-4590-8675-9137b85e73a1",
        "chunk_size": 359,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## This Book  \n*The Elements of Statistical Learning* (ESL) by Hastie, Tibshirani, and Friedman was first published in 2001. Since that time, it has become an important reference on the fundamentals of statistical machine learning. Its success derives from its comprehensive and detailed treatment of many important topics in statistical learning, as well as the fact that (relative to many upper-level statistics textbooks) it is accessible to a wide audience. However, the greatest factor behind the success of ESL has been its topical nature. At the time of its publication, interest in the field of statistical  \n{18}------------------------------------------------  \nlearning was starting to explode. ESL provided one of the first accessible and comprehensive introductions to the topic.  \nSince ESL was first published, the field of statistical learning has continued to flourish. The field's expansion has taken two forms. The most obvious growth has involved the development of new and improved statistical learning approaches aimed at answering a range of scientific questions across a number of fields. However, the field of statistical learning has also expanded its audience. In the 1990s, increases in computational power generated a surge of interest in the field from non-statisticians who were eager to use cutting-edge statistical tools to analyze their data. Unfortunately, the highly technical nature of these approaches meant that the user community remained primarily restricted to experts in statistics, computer science, and related fields with the training (and time) to understand and implement them.  \nIn recent years, new and improved software packages have significantly eased the implementation burden for many statistical learning methods. At the same time, there has been growing recognition across a number of fields, from business to health care to genetics to the social sciences and beyond, that statistical learning is a powerful tool with important practical applications. As a result, the field has moved from one of primarily academic interest to a mainstream discipline, with an enormous potential audience. This trend will surely continue with the increasing availability of enormous quantities of data and the software to analyze it.  \nThe purpose of *An Introduction to Statistical Learning* (ISL) is to facilitate the transition of statistical learning from an academic to a mainstream field. ISL is not intended to replace ESL, which is a far more comprehensive text both in terms of the number of approaches considered and the depth to which they are explored. We consider ESL to be an important companion for professionals (with graduate degrees in statistics, machine learning, or related fields) who need to understand the technical details behind statistical learning approaches. However, the community of users of statistical learning techniques has expanded to include individuals with a wider range of interests and backgrounds. Therefore, we believe that there is now a place for a less technical and more accessible version of ESL.  \nIn teaching these topics over the years, we have discovered that they are of interest to master's and PhD students in fields as disparate as business administration, biology, and computer science, as well as to quantitativelyoriented upper-division undergraduates. It is important for this diverse group to be able to understand the models, intuitions, and strengths and weaknesses of the various approaches. But for this audience, many of the technical details behind statistical learning methods, such as optimization algorithms and theoretical properties, are not of primary interest. We believe that these students do not need a deep understanding of these aspects in order to become informed users of the various methodologies, and  \n{19}------------------------------------------------  \nin order to contribute to their chosen fields through the use of statistical learning tools.  \nISLR is based on the following four premises.  \n- 1. *Many statistical learning methods are relevant and useful in a wide range of academic and non-academic disciplines, beyond just the statistical sciences.* We believe that many contemporary statistical learning procedures should, and will, become as widely available and used as is currently the case for classical methods such as linear regression. As a result, rather than attempting to consider every possible approach (an impossible task), we have concentrated on presenting the methods that we believe are most widely applicable.\n- 2. *Statistical learning should not be viewed as a series of black boxes.* No single approach will perform well in all possible applications. Without understanding all of the cogs inside the box, or the interaction between those cogs, it is impossible to select the best box. Hence, we have attempted to carefully describe the model, intuition, assumptions, and trade-offs behind each of the methods that we consider.\n- 3. *While it is important to know what job is performed by each cog, it is not necessary to have the skills to construct the machine inside the box!* Thus, we have minimized discussion of technical details related to fitting procedures and theoretical properties. We assume that the reader is comfortable with basic mathematical concepts, but we do not assume a graduate degree in the mathematical sciences. For instance, we have almost completely avoided the use of matrix algebra, and it is possible to understand the entire book without a detailed knowledge of matrices and vectors.\n- 4. *We presume that the reader is interested in applying statistical learning methods to real-world problems.* In order to facilitate this, as well as to motivate the techniques discussed, we have devoted a section within each chapter to R computer labs. In each lab, we walk the reader through a realistic application of the methods considered in that chapter. When we have taught this material in our courses, we have allocated roughly one-third of classroom time to working through the labs, and we have found them to be extremely useful. Many of the less computationally-oriented students who were initially intimidated by R's command level interface got the hang of things over the course of the quarter or semester. We have used R because it is freely available and is powerful enough to implement all of the methods discussed in the book. It also has optional packages that can be downloaded to implement literally thousands of additional methods. Most importantly, R is the language of choice for academic statisticians, and new approaches often become available in  \n{20}------------------------------------------------  \nR years before they are implemented in commercial packages. However, the labs in ISL are self-contained, and can be skipped if the reader wishes to use a different software package or does not wish to apply the methods discussed to real-world problems.",
      "metadata": {
        "header": "Introduction",
        "subheader": "This Book",
        "page": "17-20",
        "chunk_id": "chk_1e487cc7-494a-4a36-8759-e72ee508f068",
        "chunk_size": 1065,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Who Should Read This Book?  \nThis book is intended for anyone who is interested in using modern statistical methods for modeling and prediction from data. This group includes scientists, engineers, data analysts, or *quants*, but also less technical individuals with degrees in non-quantitative fields such as the social sciences or business. We expect that the reader will have had at least one elementary course in statistics. Background in linear regression is also useful, though not required, since we review the key concepts behind linear regression in Chapter 3. The mathematical level of this book is modest, and a detailed knowledge of matrix operations is not required. This book provides an introduction to the statistical programming language R. Previous exposure to a programming language, such as MATLAB or Python, is useful but not required.  \nWe have successfully taught material at this level to master's and PhD students in business, computer science, biology, earth sciences, psychology, and many other areas of the physical and social sciences. This book could also be appropriate for advanced undergraduates who have already taken a course on linear regression. In the context of a more mathematically rigorous course in which ESL serves as the primary textbook, ISL could be used as a supplementary text for teaching computational aspects of the various approaches.",
      "metadata": {
        "header": "Introduction",
        "subheader": "Who Should Read This Book?",
        "page": "20",
        "chunk_id": "chk_4bb303f4-f842-4026-aa7d-9cd19b0133af",
        "chunk_size": 216,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## Notation and Simple Matrix Algebra  \nChoosing notation for a textbook is always a difficult task. For the most part we adopt the same notational conventions as ESL.  \nWe will use n to represent the number of distinct data points, or observations, in our sample. We will let p denote the number of variables that are available for use in making predictions. For example, the Wage data set consists of 12 variables for 3,000 people, so we have n = 3,000 observations and p = 12 variables (such as year, age, wage, and more). Note that throughout this book, we indicate variable names using colored font: Variable Name.  \nIn some examples, p might be quite large, such as on the order of thousands or even millions; this situation arises quite often, for example, in the analysis of modern biological data or web-based advertising data.  \n{21}------------------------------------------------  \nIn general, we will let  $x_{ij}$  represent the value of the jth variable for the ith observation, where i = 1, 2, ..., n and j = 1, 2, ..., p. Throughout this book, i will be used to index the samples or observations (from 1 to n) and j will be used to index the variables (from 1 to p). We let  $\\mathbf{X}$  denote a  $n \\times p$  matrix whose (i, j)th element is  $x_{ij}$ . That is,  \n$$\\mathbf{X} = \\begin{pmatrix} x_{11} & x_{12} & \\dots & x_{1p} \\\\ x_{21} & x_{22} & \\dots & x_{2p} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ x_{n1} & x_{n2} & \\dots & x_{np} \\end{pmatrix}.$$  \nFor readers who are unfamiliar with matrices, it is useful to visualize  $\\mathbf{X}$  as a spreadsheet of numbers with n rows and p columns.  \nAt times we will be interested in the rows of  $\\mathbf{X}$ , which we write as  $x_1, x_2, \\ldots, x_n$ . Here  $x_i$  is a vector of length p, containing the p variable measurements for the ith observation. That is,  \n$$x_i = \\begin{pmatrix} x_{i1} \\\\ x_{i2} \\\\ \\vdots \\\\ x_{ip} \\end{pmatrix}. \\tag{1.1}$$  \n(Vectors are by default represented as columns.) For example, for the Wage data,  $x_i$  is a vector of length 12, consisting of year, age, wage, and other values for the *i*th individual. At other times we will instead be interested in the columns of  $\\mathbf{X}$ , which we write as  $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots, \\mathbf{x}_p$ . Each is a vector of length n. That is,  \n$$\\mathbf{x}_j = \\begin{pmatrix} x_{1j} \\\\ x_{2j} \\\\ \\vdots \\\\ x_{nj} \\end{pmatrix}.$$  \nFor example, for the Wage data,  $\\mathbf{x}_1$  contains the  $n=3{,}000$  values for year. Using this notation, the matrix  $\\mathbf{X}$  can be written as  \n$$\\mathbf{X} = \\begin{pmatrix} \\mathbf{x}_1 & \\mathbf{x}_2 & \\cdots & \\mathbf{x}_p \\end{pmatrix},$$  \nor  \n$$\\mathbf{X} = \\begin{pmatrix} x_1^T \\\\ x_2^T \\\\ \\vdots \\\\ x_n^T \\end{pmatrix}.$$  \n{22}------------------------------------------------  \nThe <sup>T</sup> notation denotes the *transpose* of a matrix or vector. So, for example,  \n$$\\mathbf{X}^{T} = \\begin{pmatrix} x_{11} & x_{21} & \\dots & x_{n1} \\\\ x_{12} & x_{22} & \\dots & x_{n2} \\\\ \\vdots & \\vdots & & \\vdots \\\\ x_{1p} & x_{2p} & \\dots & x_{np} \\end{pmatrix},$$  \nwhile  \n$$x_i^T = \\begin{pmatrix} x_{i1} & x_{i2} & \\cdots & x_{ip} \\end{pmatrix}.$$  \nWe use  $y_i$  to denote the *i*th observation of the variable on which we wish to make predictions, such as wage. Hence, we write the set of all n observations in vector form as  \n$$\\mathbf{y} = \\begin{pmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_n \\end{pmatrix}.$$  \nThen our observed data consists of  $\\{(x_1, y_1), (x_2, y_2), \\dots, (x_n, y_n)\\}$ , where each  $x_i$  is a vector of length p. (If p = 1, then  $x_i$  is simply a scalar.)  \nIn this text, a vector of length n will always be denoted in *lower case* bold; e.g.  \n$$\\mathbf{a} = \\begin{pmatrix} a_1 \\\\ a_2 \\\\ \\vdots \\\\ a_n \\end{pmatrix}.$$  \nHowever, vectors that are not of length n (such as feature vectors of length p, as in (1.1)) will be denoted in lower case normal font, e.g. a. Scalars will also be denoted in lower case normal font, e.g. a. In the rare cases in which these two uses for lower case normal font lead to ambiguity, we will clarify which use is intended. Matrices will be denoted using bold capitals, such as  $\\mathbf{A}$ . Random variables will be denoted using capital normal font, e.g. A, regardless of their dimensions.  \nOccasionally we will want to indicate the dimension of a particular object. To indicate that an object is a scalar, we will use the notation  $a \\in \\mathbb{R}$ . To indicate that it is a vector of length k, we will use  $a \\in \\mathbb{R}^k$  (or  $\\mathbf{a} \\in \\mathbb{R}^n$  if it is of length n). We will indicate that an object is a  $r \\times s$  matrix using  $\\mathbf{A} \\in \\mathbb{R}^{r \\times s}$ .  \nWe have avoided using matrix algebra whenever possible. However, in a few instances it becomes too cumbersome to avoid it entirely. In these rare instances it is important to understand the concept of multiplying two matrices. Suppose that  $\\mathbf{A} \\in \\mathbb{R}^{r \\times d}$  and  $\\mathbf{B} \\in \\mathbb{R}^{d \\times s}$ . Then the product  \n{23}------------------------------------------------  \nof **A** and **B** is denoted **AB**. The (i, j)th element of **AB** is computed by multiplying each element of the *i*th row of **A** by the corresponding element of the *j*th column of **B**. That is,  $(\\mathbf{AB})_{ij} = \\sum_{k=1}^{d} a_{ik}b_{kj}$ . As an example, consider  \n$$\\mathbf{A} = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\quad \\text{and} \\quad \\mathbf{B} = \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix}.$$  \nThen  \n$$\\mathbf{AB} = \\begin{pmatrix} 1 & 2 \\\\ 3 & 4 \\end{pmatrix} \\begin{pmatrix} 5 & 6 \\\\ 7 & 8 \\end{pmatrix} = \\begin{pmatrix} 1 \\times 5 + 2 \\times 7 & 1 \\times 6 + 2 \\times 8 \\\\ 3 \\times 5 + 4 \\times 7 & 3 \\times 6 + 4 \\times 8 \\end{pmatrix} = \\begin{pmatrix} 19 & 22 \\\\ 43 & 50 \\end{pmatrix}.$$  \nNote that this operation produces an  $r \\times s$  matrix. It is only possible to compute  $\\mathbf{AB}$  if the number of columns of  $\\mathbf{A}$  is the same as the number of rows of  $\\mathbf{B}$ .",
      "metadata": {
        "header": "Introduction",
        "subheader": "Notation and Simple Matrix Algebra",
        "page": "20-23",
        "chunk_id": "chk_172388c9-ebc4-43fe-b1f5-437cdec0e49b",
        "chunk_size": 1012,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Organization of This Book  \nChapter 2 introduces the basic terminology and concepts behind statistical learning. This chapter also presents the K-nearest neighbor classifier, a very simple method that works surprisingly well on many problems. Chapters 3 and 4 cover classical linear methods for regression and classification. In particular, Chapter 3 reviews linear regression, the fundamental starting point for all regression methods. In Chapter 4 we discuss two of the most important classical classification methods, logistic regression and linear discriminant analysis.  \nA central problem in all statistical learning situations involves choosing the best method for a given application. Hence, in Chapter 5 we introduce *cross-validation* and the *bootstrap*, which can be used to estimate the accuracy of a number of different methods in order to choose the best one.  \nMuch of the recent research in statistical learning has concentrated on non-linear methods. However, linear methods often have advantages over their non-linear competitors in terms of interpretability and sometimes also accuracy. Hence, in Chapter 6 we consider a host of linear methods, both classical and more modern, which offer potential improvements over standard linear regression. These include stepwise selection, ridge regression, principal components regression, partial least squares, and the lasso.  \nThe remaining chapters move into the world of non-linear statistical learning. We first introduce in Chapter 7 a number of non-linear methods that work well for problems with a single input variable. We then show how these methods can be used to fit non-linear additive models for which there is more than one input. In Chapter 8, we investigate tree-based methods, including bagging, boosting, and random forests. Support vector machines, a set of approaches for performing both linear and non-linear classification,  \n{24}------------------------------------------------  \nare discussed in Chapter 9. Finally, in Chapter 10, we consider a setting in which we have input variables but no output variable. In particular, we present *principal components analysis*, K*-means clustering*, and *hierarchical clustering*.  \nAt the end of each chapter, we present one or more R lab sections in which we systematically work through applications of the various methods discussed in that chapter. These labs demonstrate the strengths and weaknesses of the various approaches, and also provide a useful reference for the syntax required to implement the various methods. The reader may choose to work through the labs at his or her own pace, or the labs may be the focus of group sessions as part of a classroom environment. Within each R lab, we present the results that we obtained when we performed the lab at the time of writing this book. However, new versions of R are continuously released, and over time, the packages called in the labs will be updated. Therefore, in the future, it is possible that the results shown in the lab sections may no longer correspond precisely to the results obtained by the reader who performs the labs. As necessary, we will post updates to the labs on the book website.  \nWe use the symbol to denote sections or exercises that contain more challenging concepts. These can be easily skipped by readers who do not wish to delve as deeply into the material, or who lack the mathematical background.",
      "metadata": {
        "header": "Introduction",
        "subheader": "Organization of This Book",
        "page": "23-24",
        "chunk_id": "chk_2a1d955a-7d41-4b6e-b3e7-e9ac967a002a",
        "chunk_size": 527,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## Data Sets Used in Labs and Exercises  \nIn this textbook, we illustrate statistical learning methods using applications from marketing, finance, biology, and other areas. The ISLR package available on the book website contains a number of data sets that are required in order to perform the labs and exercises associated with this book. One other data set is contained in the MASS library, and yet another is part of the base R distribution. Table 1.1 contains a summary of the data sets required to perform the labs and exercises. A couple of these data sets are also available as text files on the book website, for use in Chapter 2.",
      "metadata": {
        "header": "Introduction",
        "subheader": "Data Sets Used in Labs and Exercises",
        "page": "24",
        "chunk_id": "chk_568dca5f-79b5-4e6e-8d5d-532842bdcd0f",
        "chunk_size": 111,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## Book Website  \nThe website for this book is located at  \n{25}------------------------------------------------  \n| Name      | Description                                                       |\n|-----------|-------------------------------------------------------------------|\n| Auto      | Gas mileage, horsepower, and other information for cars.          |\n| Boston    | Housing values and other information about Boston suburbs.        |\n| Caravan   | Information about individuals offered caravan insurance.          |\n| Carseats  | Information about car seat sales in 400 stores.                   |\n| College   | Demographic characteristics, tuition, and more for USA colleges.  |\n| Default   | Customer default records for a credit card company.               |\n| Hitters   | Records and salaries for baseball players.                        |\n| Khan      | Gene expression measurements for four cancer types.               |\n| NCI60     | Gene expression measurements for 64 cancer cell lines.            |\n| OJ        | Sales information for Citrus Hill and Minute Maid orange juice.   |\n| Portfolio | Past values of financial assets, for use in portfolio allocation. |\n| Smarket   | Daily percentage returns for S&P 500 over a 5-year period.        |\n| USArrests | Crime statistics per 100,000 residents in 50 states of USA.       |\n| Wage      | Income survey data for males in central Atlantic region of USA.   |\n| Weekly    | 1,089 weekly stock market returns for 21 years.                   |  \n**TABLE 1.1.** A list of data sets needed to perform the labs and exercises in this textbook. All data sets are available in the ISLR library, with the exception of Boston (part of MASS) and USArrests (part of the base R distribution).  \nIt contains a number of resources, including the R package associated with this book, and some additional data sets.",
      "metadata": {
        "header": "Introduction",
        "subheader": "Book Website",
        "page": "24-25",
        "chunk_id": "chk_7d6b64c1-bc23-41e9-a7e1-e7c61a2cbd4c",
        "chunk_size": 265,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### Acknowledgements  \nA few of the plots in this book were taken from ESL: Figures 6.7, 8.3, and 10.12. All other plots are new to this book.  \n{26}------------------------------------------------",
      "metadata": {
        "header": "Introduction",
        "subheader": "Acknowledgements",
        "page": "25-26",
        "chunk_id": "chk_5969483d-8919-4987-afdf-65d0d6f30ea9",
        "chunk_size": 28,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# Statistical Learning  \n#### What Is Statistical Learning? 2.1  \nIn order to motivate our study of statistical learning, we begin with a simple example. Suppose that we are statistical consultants hired by a client to provide advice on how to improve sales of a particular product. The Advertising data set consists of the sales of that product in 200 different markets, along with advertising budgets for the product in each of those markets for three different media: TV, radio, and newspaper. The data are displayed in Figure 2.1. It is not possible for our client to directly increase sales of the product. On the other hand, they can control the advertising expenditure in each of the three media. Therefore, if we determine that there is an association between advertising and sales, then we can instruct our client to adjust advertising budgets, thereby indirectly increasing sales. In other words, our goal is to develop an accurate model that can be used to predict sales on the basis of the three media budgets.  \nIn this setting, the advertising budgets are input variables while sales is an *output variable*. The input variables are typically denoted using the symbol X, with a subscript to distinguish them. So  $X_1$  might be the TV budget,  $X_2$  the radio budget, and  $X_3$  the newspaper budget. The inputs go by different names, such as predictors, independent variables, features, or sometimes just variables. The output variable—in this case, sales—is often called the response or dependent variable, and is typically denoted variable using the symbol Y. Throughout this book, we will use all of these terms interchangeably.  \noutput variable  \npredictor independent feature variable response dependent variable  \n15  \nG. James et al., An Introduction to Statistical Learning: with Applications in R. Springer Texts in Statistics, DOI 10.1007/978-1-4614-7138-7\\_2, © Springer Science+Business Media New York 2013  \n{27}------------------------------------------------  \n![](_page_27_Figure_2.jpeg)  \nFIGURE 2.1. The Advertising data set. The plot displays sales, in thousands of units, as a function of TV, radio, and newspaper budgets, in thousands of dollars, for 200 different markets. In each plot we show the simple least squares fit of sales to that variable, as described in Chapter 3. In other words, each blue line represents a simple model that can be used to predict sales using TV, radio, and newspaper, respectively.  \nMore generally, suppose that we observe a quantitative response Y and p different predictors,  $X_1, X_2, \\ldots, X_p$ . We assume that there is some relationship between Y and  $X = (X_1, X_2, \\ldots, X_p)$ , which can be written in the very general form  \n$$Y = f(X) + \\epsilon. \\tag{2.1}$$  \nHere f is some fixed but unknown function of  $X_1, \\ldots, X_p$ , and  $\\epsilon$  is a random error term, which is independent of X and has mean zero. In this formulation, f represents the systematic information that X provides about Y.  \nerror term systematic  \nAs another example, consider the left-hand panel of Figure 2.2, a plot of income versus years of education for 30 individuals in the Income data set. The plot suggests that one might be able to predict income using years of education. However, the function f that connects the input variable to the output variable is in general unknown. In this situation one must estimate f based on the observed points. Since Income is a simulated data set, f is known and is shown by the blue curve in the right-hand panel of Figure 2.2. The vertical lines represent the error terms  $\\epsilon$ . We note that some of the 30 observations lie above the blue curve and some lie below it; overall, the errors have approximately mean zero.  \nIn general, the function f may involve more than one input variable. In Figure 2.3 we plot income as a function of years of education and seniority. Here f is a two-dimensional surface that must be estimated based on the observed data.  \n{28}------------------------------------------------  \n![](_page_28_Figure_2.jpeg)  \nFIGURE 2.2. The Income data set. Left: The red dots are the observed values of income (in tens of thousands of dollars) and years of education for 30 individuals. Right: The blue curve represents the true underlying relationship between income and years of education, which is generally unknown (but is known in this case because the data were simulated). The black lines represent the error associated with each observation. Note that some errors are positive (if an observation lies above the blue curve) and some are negative (if an observation lies below the curve). Overall, these errors have approximately mean zero.  \nIn essence, statistical learning refers to a set of approaches for estimating f. In this chapter we outline some of the key theoretical concepts that arise in estimating f, as well as tools for evaluating the estimates obtained.",
      "metadata": {
        "header": "Statistical Learning",
        "subheader": "What Is Statistical Learning? 2.1",
        "page": "26-28",
        "chunk_id": "chk_317d895a-26cf-4328-b2ec-89ee8558be58",
        "chunk_size": 786,
        "chunk_img_path": "_page_27_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_27_Figure_2.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### 2.1.1 Why Estimate f?  \nThere are two main reasons that we may wish to estimate f: prediction and inference. We discuss each in turn.",
      "metadata": {
        "header": "Statistical Learning",
        "subheader": "2.1.1 Why Estimate f?",
        "page": "28",
        "chunk_id": "chk_052cc413-c552-4303-8fa0-3aa538895a6e",
        "chunk_size": 25,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Prediction  \nIn many situations, a set of inputs X are readily available, but the output Y cannot be easily obtained. In this setting, since the error term averages to zero, we can predict Y using  \n$$\\hat{Y} = \\hat{f}(X), \\tag{2.2}$$  \nwhere  $\\hat{f}$  represents our estimate for f, and  $\\hat{Y}$  represents the resulting prediction for Y. In this setting,  $\\hat{f}$  is often treated as a *black box*, in the sense that one is not typically concerned with the exact form of  $\\hat{f}$ , provided that it yields accurate predictions for Y.  \n{29}------------------------------------------------  \n![](_page_29_Figure_2.jpeg)  \n**FIGURE 2.3.** The plot displays income as a function of years of education and seniority in the Income data set. The blue surface represents the true underlying relationship between income and years of education and seniority, which is known since the data are simulated. The red dots indicate the observed values of these quantities for 30 individuals.  \nAs an example, suppose that X1,...,X<sup>p</sup> are characteristics of a patient's blood sample that can be easily measured in a lab, and Y is a variable encoding the patient's risk for a severe adverse reaction to a particular drug. It is natural to seek to predict Y using X, since we can then avoid giving the drug in question to patients who are at high risk of an adverse reaction—that is, patients for whom the estimate of Y is high.  \nThe accuracy of Yˆ as a prediction for Y depends on two quantities, which we will call the *reducible error* and the *irreducible error*. In general, reducible ˆf will not be a perfect estimate for f, and this inaccuracy will introduce some error. This error is *reducible* because we can potentially improve the accuracy of ˆf by using the most appropriate statistical learning technique to estimate f. However, even if it were possible to form a perfect estimate for f, so that our estimated response took the form Yˆ = f(X), our prediction would still have some error in it! This is because Y is also a function of , which, by definition, cannot be predicted using X. Therefore, variability associated with also affects the accuracy of our predictions. This is known as the *irreducible* error, because no matter how well we estimate f, we cannot reduce the error introduced by .  \nWhy is the irreducible error larger than zero? The quantity may contain unmeasured variables that are useful in predicting Y : since we don't measure them, f cannot use them for its prediction. The quantity may also contain unmeasurable variation. For example, the risk of an adverse reaction might vary for a given patient on a given day, depending on  \nerror irreducible error",
      "metadata": {
        "header": "Statistical Learning",
        "subheader": "Prediction",
        "page": "28-29",
        "chunk_id": "chk_6d573e86-5a6c-4db1-85a2-5db3b00d8a87",
        "chunk_size": 444,
        "chunk_img_path": "_page_29_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\_page_29_Figure_2.jpeg",
        "file_id": "fi_03f9e37a-b5db-4c95-959b-9ac5c5e04a18",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30\\ISLR_1stEd-1-30.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\ISLR_1stEd-1-30",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "{0}------------------------------------------------",
      "metadata": {
        "header": null,
        "subheader": null,
        "page": "0",
        "chunk_id": "chk_4a51c956-b3be-4913-b277-54e9b319ba77",
        "chunk_size": 1,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **The Machine Learning Landscape**  \n![](_page_0_Picture_2.jpeg)  \nWith Early Release ebooks, you get books in their earliest form the author's raw and unedited content as he or she writes—so you can take advantage of these technologies long before the official release of these titles. The following will be Chapter 1 in the final release of the book.  \nWhen most people hear \"Machine Learning,\" they picture a robot: a dependable but‐ ler or a deadly Terminator depending on who you ask. But Machine Learning is not just a futuristic fantasy, it's already here. In fact, it has been around for decades in some specialized applications, such as *Optical Character Recognition* (OCR). But the first ML application that really became mainstream, improving the lives of hundreds of millions of people, took over the world back in the 1990s: it was the *spam filter*. Not exactly a self-aware Skynet, but it does technically qualify as Machine Learning (it has actually learned so well that you seldom need to flag an email as spam any‐ more). It was followed by hundreds of ML applications that now quietly power hun‐ dreds of products and features that you use regularly, from better recommendations to voice search.  \nWhere does Machine Learning start and where does it end? What exactly does it mean for a machine to *learn* something? If I download a copy of Wikipedia, has my computer really \"learned\" something? Is it suddenly smarter? In this chapter we will start by clarifying what Machine Learning is and why you may want to use it.  \nThen, before we set out to explore the Machine Learning continent, we will take a look at the map and learn about the main regions and the most notable landmarks: supervised versus unsupervised learning, online versus batch learning, instancebased versus model-based learning. Then we will look at the workflow of a typical ML project, discuss the main challenges you may face, and cover how to evaluate and fine-tune a Machine Learning system.  \n{1}------------------------------------------------  \nThis chapter introduces a lot of fundamental concepts (and jargon) that every data scientist should know by heart. It will be a high-level overview (the only chapter without much code), all rather simple, but you should make sure everything is crystal-clear to you before continuing to the rest of the book. So grab a coffee and let's get started!  \n![](_page_1_Picture_1.jpeg)  \nIf you already know all the Machine Learning basics, you may want to skip directly to [Chapter 2.](#page-34-0) If you are not sure, try to answer all the questions listed at the end of the chapter before moving on.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": null,
        "page": "0-1",
        "chunk_id": "chk_ecc9ee42-9a95-4455-84cd-f7314a45e42b",
        "chunk_size": 429,
        "chunk_img_path": "_page_0_Picture_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_0_Picture_2.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **What Is Machine Learning?**  \nMachine Learning is the science (and art) of programming computers so they can *learn from data*.  \nHere is a slightly more general definition:  \n[Machine Learning is the] field of study that gives computers the ability to learn without being explicitly programmed.  \n—Arthur Samuel, *1959*  \nAnd a more engineering-oriented one:  \nA computer program is said to learn from experience E with respect to some task T and some performance measure P, if its performance on T, as measured by P, improves with experience E.  \n—Tom Mitchell, *1997*  \nFor example, your spam filter is a Machine Learning program that can learn to flag spam given examples of spam emails (e.g., flagged by users) and examples of regular (nonspam, also called \"ham\") emails. The examples that the system uses to learn are called the *training set*. Each training example is called a *training instance* (or *sample*). In this case, the task T is to flag spam for new emails, the experience E is the *training data*, and the performance measure P needs to be defined; for example, you can use the ratio of correctly classified emails. This particular performance measure is called *accuracy* and it is often used in classification tasks.  \nIf you just download a copy of Wikipedia, your computer has a lot more data, but it is not suddenly better at any task. Thus, it is not Machine Learning.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**What Is Machine Learning?**",
        "page": "1",
        "chunk_id": "chk_b83819ad-27ff-4332-ba46-38e85fa442a4",
        "chunk_size": 233,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Why Use Machine Learning?**  \nConsider how you would write a spam filter using traditional programming techni‐ ques [\\(Figure 1-1\\)](#page-2-0):  \n{2}------------------------------------------------  \n- <span id=\"page-2-0\"></span>1. First you would look at what spam typically looks like. You might notice that some words or phrases (such as \"4U,\" \"credit card,\" \"free,\" and \"amazing\") tend to come up a lot in the subject. Perhaps you would also notice a few other patterns in the sender's name, the email's body, and so on.\n- 2. You would write a detection algorithm for each of the patterns that you noticed, and your program would flag emails as spam if a number of these patterns are detected.\n- 3. You would test your program, and repeat steps 1 and 2 until it is good enough.  \n![](_page_2_Figure_3.jpeg)  \n*Figure 1-1. The traditional approach*  \nSince the problem is not trivial, your program will likely become a long list of com‐ plex rules—pretty hard to maintain.  \nIn contrast, a spam filter based on Machine Learning techniques automatically learns which words and phrases are good predictors of spam by detecting unusually fre‐ quent patterns of words in the spam examples compared to the ham examples ([Figure 1-2\\)](#page-3-0). The program is much shorter, easier to maintain, and most likely more accurate.  \n{3}------------------------------------------------  \n<span id=\"page-3-0\"></span>![](_page_3_Figure_0.jpeg)  \n*Figure 1-2. Machine Learning approach*  \nMoreover, if spammers notice that all their emails containing \"4U\" are blocked, they might start writing \"For U\" instead. A spam filter using traditional programming techniques would need to be updated to flag \"For U\" emails. If spammers keep work‐ ing around your spam filter, you will need to keep writing new rules forever.  \nIn contrast, a spam filter based on Machine Learning techniques automatically noti‐ ces that \"For U\" has become unusually frequent in spam flagged by users, and it starts flagging them without your intervention (Figure 1-3).  \n![](_page_3_Figure_4.jpeg)  \n*Figure 1-3. Automatically adapting to change*  \nAnother area where Machine Learning shines is for problems that either are too com‐ plex for traditional approaches or have no known algorithm. For example, consider speech recognition: say you want to start simple and write a program capable of dis‐ tinguishing the words \"one\" and \"two.\" You might notice that the word \"two\" starts with a high-pitch sound (\"T\"), so you could hardcode an algorithm that measures high-pitch sound intensity and use that to distinguish ones and twos. Obviously this technique will not scale to thousands of words spoken by millions of very different  \n{4}------------------------------------------------  \npeople in noisy environments and in dozens of languages. The best solution (at least today) is to write an algorithm that learns by itself, given many example recordings for each word.  \nFinally, Machine Learning can help humans learn (Figure 1-4): ML algorithms can be inspected to see what they have learned (although for some algorithms this can be tricky). For instance, once the spam filter has been trained on enough spam, it can easily be inspected to reveal the list of words and combinations of words that it believes are the best predictors of spam. Sometimes this will reveal unsuspected cor‐ relations or new trends, and thereby lead to a better understanding of the problem.  \nApplying ML techniques to dig into large amounts of data can help discover patterns that were not immediately apparent. This is called *data mining*.  \n![](_page_4_Figure_3.jpeg)  \n*Figure 1-4. Machine Learning can help humans learn*  \nTo summarize, Machine Learning is great for:  \n- Problems for which existing solutions require a lot of hand-tuning or long lists of rules: one Machine Learning algorithm can often simplify code and perform bet‐ ter.\n- Complex problems for which there is no good solution at all using a traditional approach: the best Machine Learning techniques can find a solution.\n- Fluctuating environments: a Machine Learning system can adapt to new data.\n- Getting insights about complex problems and large amounts of data.  \n{5}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Why Use Machine Learning?**",
        "page": "1-5",
        "chunk_id": "chk_be24ce7a-ea53-4830-8056-11a24a1ccbf1",
        "chunk_size": 640,
        "chunk_img_path": "_page_2_Figure_3.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_2_Figure_3.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Types of Machine Learning Systems**  \nThere are so many different types of Machine Learning systems that it is useful to classify them in broad categories based on:  \n- Whether or not they are trained with human supervision (supervised, unsuper‐ vised, semisupervised, and Reinforcement Learning)\n- Whether or not they can learn incrementally on the fly (online versus batch learning)\n- Whether they work by simply comparing new data points to known data points, or instead detect patterns in the training data and build a predictive model, much like scientists do (instance-based versus model-based learning)  \nThese criteria are not exclusive; you can combine them in any way you like. For example, a state-of-the-art spam filter may learn on the fly using a deep neural net‐ work model trained using examples of spam and ham; this makes it an online, modelbased, supervised learning system.  \nLet's look at each of these criteria a bit more closely.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Types of Machine Learning Systems**",
        "page": "5",
        "chunk_id": "chk_683b1a41-e495-49b2-8eb5-fdd693e1c177",
        "chunk_size": 154,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Supervised/Unsupervised Learning**  \nMachine Learning systems can be classified according to the amount and type of supervision they get during training. There are four major categories: supervised learning, unsupervised learning, semisupervised learning, and Reinforcement Learn‐ ing.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Supervised/Unsupervised Learning**",
        "page": "5",
        "chunk_id": "chk_b646fb90-1466-49d5-bba4-de963dd745a2",
        "chunk_size": 36,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Supervised learning**  \nIn *supervised learning*, the training data you feed to the algorithm includes the desired solutions, called *labels* (Figure 1-5).  \n![](_page_5_Picture_11.jpeg)  \n*Figure 1-5. A labeled training set for supervised learning (e.g., spam classification)*  \n{6}------------------------------------------------  \nA typical supervised learning task is *classification*. The spam filter is a good example of this: it is trained with many example emails along with their *class* (spam or ham), and it must learn how to classify new emails.  \nAnother typical task is to predict a *target* numeric value, such as the price of a car, given a set of *features* (mileage, age, brand, etc.) called *predictors*. This sort of task is called *regression* (Figure 1-6).<sup>1</sup> To train the system, you need to give it many examples of cars, including both their predictors and their labels (i.e., their prices).  \n![](_page_6_Picture_2.jpeg)  \nIn Machine Learning an *attribute* is a data type (e.g., \"Mileage\"), while a *feature* has several meanings depending on the context, but generally means an attribute plus its value (e.g., \"Mileage = 15,000\"). Many people use the words *attribute* and *feature* inter‐ changeably, though.  \n![](_page_6_Figure_4.jpeg)  \n*Figure 1-6. Regression*  \nNote that some regression algorithms can be used for classification as well, and vice versa. For example, *Logistic Regression* is commonly used for classification, as it can output a value that corresponds to the probability of belonging to a given class (e.g., 20% chance of being spam).  \n<sup>1</sup> Fun fact: this odd-sounding name is a statistics term introduced by Francis Galton while he was studying the fact that the children of tall people tend to be shorter than their parents. Since children were shorter, he called this *regression to the mean*. This name was then applied to the methods he used to analyze correlations between variables.  \n{7}------------------------------------------------  \nHere are some of the most important supervised learning algorithms (covered in this book):  \n- k-Nearest Neighbors\n- Linear Regression\n- Logistic Regression\n- Support Vector Machines (SVMs)\n- Decision Trees and Random Forests\n- Neural networks<sup>2</sup>",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Supervised learning**",
        "page": "5-7",
        "chunk_id": "chk_00ab4c24-c684-4d45-8e6a-8c1e2124c0e5",
        "chunk_size": 328,
        "chunk_img_path": "_page_5_Picture_11.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_5_Picture_11.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Unsupervised learning**  \nIn *unsupervised learning*, as you might guess, the training data is unlabeled (Figure 1-7). The system tries to learn without a teacher.  \n![](_page_7_Picture_9.jpeg)  \n*Figure 1-7. An unlabeled training set for unsupervised learning*  \nHere are some of the most important unsupervised learning algorithms (most of these are covered in Chapter 8 and Chapter 9):  \n- Clustering\n- K-Means\n- DBSCAN\n- Hierarchical Cluster Analysis (HCA)\n- Anomaly detection and novelty detection\n- One-class SVM\n- Isolation Forest  \n<sup>2</sup> Some neural network architectures can be unsupervised, such as autoencoders and restricted Boltzmann machines. They can also be semisupervised, such as in deep belief networks and unsupervised pretraining.  \n{8}------------------------------------------------  \n- Visualization and dimensionality reduction\n- Principal Component Analysis (PCA)\n- Kernel PCA\n- Locally-Linear Embedding (LLE)\n- t-distributed Stochastic Neighbor Embedding (t-SNE)\n- Association rule learning\n- Apriori\n- Eclat  \nFor example, say you have a lot of data about your blog's visitors. You may want to run a *clustering* algorithm to try to detect groups of similar visitors (Figure 1-8). At no point do you tell the algorithm which group a visitor belongs to: it finds those connections without your help. For example, it might notice that 40% of your visitors are males who love comic books and generally read your blog in the evening, while 20% are young sci-fi lovers who visit during the weekends, and so on. If you use a *hierarchical clustering* algorithm, it may also subdivide each group into smaller groups. This may help you target your posts for each group.  \n![](_page_8_Figure_9.jpeg)  \n*Figure 1-8. Clustering*  \n*Visualization* algorithms are also good examples of unsupervised learning algorithms: you feed them a lot of complex and unlabeled data, and they output a 2D or 3D rep‐ resentation of your data that can easily be plotted [\\(Figure 1-9](#page-9-0)). These algorithms try to preserve as much structure as they can (e.g., trying to keep separate clusters in the input space from overlapping in the visualization), so you can understand how the data is organized and perhaps identify unsuspected patterns.  \n{9}------------------------------------------------  \n<span id=\"page-9-0\"></span>![](_page_9_Figure_0.jpeg)  \n*Figure 1-9. Example of a t-SNE visualization highlighting semantic clusters<sup>3</sup>*  \nA related task is *dimensionality reduction*, in which the goal is to simplify the data without losing too much information. One way to do this is to merge several correla‐ ted features into one. For example, a car's mileage may be very correlated with its age, so the dimensionality reduction algorithm will merge them into one feature that rep‐ resents the car's wear and tear. This is called *feature extraction*.  \n![](_page_9_Picture_3.jpeg)  \nIt is often a good idea to try to reduce the dimension of your train‐ ing data using a dimensionality reduction algorithm before you feed it to another Machine Learning algorithm (such as a super‐ vised learning algorithm). It will run much faster, the data will take up less disk and memory space, and in some cases it may also per‐ form better.  \nYet another important unsupervised task is *anomaly detection*—for example, detect‐ ing unusual credit card transactions to prevent fraud, catching manufacturing defects, or automatically removing outliers from a dataset before feeding it to another learn‐ ing algorithm. The system is shown mostly normal instances during training, so it learns to recognize them and when it sees a new instance it can tell whether it looks  \n<sup>3</sup> Notice how animals are rather well separated from vehicles, how horses are close to deer but far from birds, and so on. Figure reproduced with permission from Socher, Ganjoo, Manning, and Ng (2013), \"T-SNE visual‐ ization of the semantic word space.\"  \n{10}------------------------------------------------  \nlike a normal one or whether it is likely an anomaly (see Figure 1-10). A very similar task is *novelty detection*: the difference is that novelty detection algorithms expect to see only normal data during training, while anomaly detection algorithms are usually more tolerant, they can often perform well even with a small percentage of outliers in the training set.  \n![](_page_10_Figure_1.jpeg)  \n*Figure 1-10. Anomaly detection*  \nFinally, another common unsupervised task is *association rule learning*, in which the goal is to dig into large amounts of data and discover interesting relations between attributes. For example, suppose you own a supermarket. Running an association rule on your sales logs may reveal that people who purchase barbecue sauce and potato chips also tend to buy steak. Thus, you may want to place these items close to each other.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Unsupervised learning**",
        "page": "7-10",
        "chunk_id": "chk_f1091061-e47c-44d1-bf6c-feb3c7dc2593",
        "chunk_size": 728,
        "chunk_img_path": "_page_7_Picture_9.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_7_Picture_9.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Semisupervised learning**  \nSome algorithms can deal with partially labeled training data, usually a lot of unla‐ beled data and a little bit of labeled data. This is called *semisupervised learning* ([Figure 1-11](#page-11-0)).  \nSome photo-hosting services, such as Google Photos, are good examples of this. Once you upload all your family photos to the service, it automatically recognizes that the same person A shows up in photos 1, 5, and 11, while another person B shows up in photos 2, 5, and 7. This is the unsupervised part of the algorithm (clustering). Now all the system needs is for you to tell it who these people are. Just one label per person,<sup>4</sup> and it is able to name everyone in every photo, which is useful for searching photos.  \n<sup>4</sup> That's when the system works perfectly. In practice it often creates a few clusters per person, and sometimes mixes up two people who look alike, so you need to provide a few labels per person and manually clean up some clusters.  \n{11}------------------------------------------------  \n<span id=\"page-11-0\"></span>![](_page_11_Figure_0.jpeg)  \n*Figure 1-11. Semisupervised learning*  \nMost semisupervised learning algorithms are combinations of unsupervised and supervised algorithms. For example, *deep belief networks* (DBNs) are based on unsu‐ pervised components called *restricted Boltzmann machines* (RBMs) stacked on top of one another. RBMs are trained sequentially in an unsupervised manner, and then the whole system is fine-tuned using supervised learning techniques.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Semisupervised learning**",
        "page": "10-11",
        "chunk_id": "chk_6f722d70-d99e-46d6-ba3a-ebdc1659ea79",
        "chunk_size": 230,
        "chunk_img_path": "_page_11_Figure_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_11_Figure_0.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Reinforcement Learning**  \n*Reinforcement Learning* is a very different beast. The learning system, called an *agent* in this context, can observe the environment, select and perform actions, and get *rewards* in return (or *penalties* in the form of negative rewards, as in [Figure 1-12\\)](#page-12-0). It must then learn by itself what is the best strategy, called a *policy*, to get the most reward over time. A policy defines what action the agent should choose when it is in a given situation.  \n{12}------------------------------------------------  \n<span id=\"page-12-0\"></span>![](_page_12_Picture_0.jpeg)  \n*Figure 1-12. Reinforcement Learning*  \nFor example, many robots implement Reinforcement Learning algorithms to learn how to walk. DeepMind's AlphaGo program is also a good example of Reinforcement Learning: it made the headlines in May 2017 when it beat the world champion Ke Jie at the game of *Go*. It learned its winning policy by analyzing millions of games, and then playing many games against itself. Note that learning was turned off during the games against the champion; AlphaGo was just applying the policy it had learned.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Reinforcement Learning**",
        "page": "11-12",
        "chunk_id": "chk_e857dd31-66f6-4109-a36d-2a54a5f67b1c",
        "chunk_size": 170,
        "chunk_img_path": "_page_12_Picture_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_12_Picture_0.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Batch and Online Learning**  \nAnother criterion used to classify Machine Learning systems is whether or not the system can learn incrementally from a stream of incoming data.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Batch and Online Learning**",
        "page": "12",
        "chunk_id": "chk_40d3967d-e3a8-451b-8c55-717a4c6248b5",
        "chunk_size": 28,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Batch learning**  \nIn *batch learning*, the system is incapable of learning incrementally: it must be trained using all the available data. This will generally take a lot of time and computing resources, so it is typically done offline. First the system is trained, and then it is launched into production and runs without learning anymore; it just applies what it has learned. This is called *offline learning*.  \nIf you want a batch learning system to know about new data (such as a new type of spam), you need to train a new version of the system from scratch on the full dataset (not just the new data, but also the old data), then stop the old system and replace it with the new one.  \nFortunately, the whole process of training, evaluating, and launching a Machine Learning system can be automated fairly easily (as shown in [Figure 1-3\\)](#page-3-0), so even a  \n{13}------------------------------------------------  \nbatch learning system can adapt to change. Simply update the data and train a new version of the system from scratch as often as needed.  \nThis solution is simple and often works fine, but training using the full set of data can take many hours, so you would typically train a new system only every 24 hours or even just weekly. If your system needs to adapt to rapidly changing data (e.g., to pre‐ dict stock prices), then you need a more reactive solution.  \nAlso, training on the full set of data requires a lot of computing resources (CPU, memory space, disk space, disk I/O, network I/O, etc.). If you have a lot of data and you automate your system to train from scratch every day, it will end up costing you a lot of money. If the amount of data is huge, it may even be impossible to use a batch learning algorithm.  \nFinally, if your system needs to be able to learn autonomously and it has limited resources (e.g., a smartphone application or a rover on Mars), then carrying around large amounts of training data and taking up a lot of resources to train for hours every day is a showstopper.  \nFortunately, a better option in all these cases is to use algorithms that are capable of learning incrementally.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Batch learning**",
        "page": "12-13",
        "chunk_id": "chk_65600a2f-6895-4557-9c79-2f22d7696061",
        "chunk_size": 373,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Online learning**  \nIn *online learning*, you train the system incrementally by feeding it data instances sequentially, either individually or by small groups called *mini-batches*. Each learning step is fast and cheap, so the system can learn about new data on the fly, as it arrives (see Figure 1-13).  \n![](_page_13_Figure_7.jpeg)  \n*Figure 1-13. Online learning*  \nOnline learning is great for systems that receive data as a continuous flow (e.g., stock prices) and need to adapt to change rapidly or autonomously. It is also a good option  \n{14}------------------------------------------------  \nif you have limited computing resources: once an online learning system has learned about new data instances, it does not need them anymore, so you can discard them (unless you want to be able to roll back to a previous state and \"replay\" the data). This can save a huge amount of space.  \nOnline learning algorithms can also be used to train systems on huge datasets that cannot fit in one machine's main memory (this is called *out-of-core* learning). The algorithm loads part of the data, runs a training step on that data, and repeats the process until it has run on all of the data (see Figure 1-14).  \n![](_page_14_Picture_2.jpeg)  \nOut-of-core learning is usually done offline (i.e., not on the live system), so *online learning* can be a confusing name. Think of it as *incremental learning*.  \n![](_page_14_Figure_4.jpeg)  \n*Figure 1-14. Using online learning to handle huge datasets*  \nOne important parameter of online learning systems is how fast they should adapt to changing data: this is called the *learning rate*. If you set a high learning rate, then your system will rapidly adapt to new data, but it will also tend to quickly forget the old data (you don't want a spam filter to flag only the latest kinds of spam it was shown). Conversely, if you set a low learning rate, the system will have more inertia; that is, it will learn more slowly, but it will also be less sensitive to noise in the new data or to sequences of nonrepresentative data points (outliers).  \nA big challenge with online learning is that if bad data is fed to the system, the sys‐ tem's performance will gradually decline. If we are talking about a live system, your clients will notice. For example, bad data could come from a malfunctioning sensor on a robot, or from someone spamming a search engine to try to rank high in search  \n{15}------------------------------------------------  \nresults. To reduce this risk, you need to monitor your system closely and promptly switch learning off (and possibly revert to a previously working state) if you detect a drop in performance. You may also want to monitor the input data and react to abnormal data (e.g., using an anomaly detection algorithm).",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Online learning**",
        "page": "13-15",
        "chunk_id": "chk_766d9da9-d471-4510-acd1-4eba3aa17199",
        "chunk_size": 455,
        "chunk_img_path": "_page_13_Figure_7.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_13_Figure_7.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Instance-Based Versus Model-Based Learning**  \nOne more way to categorize Machine Learning systems is by how they *generalize*. Most Machine Learning tasks are about making predictions. This means that given a number of training examples, the system needs to be able to generalize to examples it has never seen before. Having a good performance measure on the training data is good, but insufficient; the true goal is to perform well on new instances.  \nThere are two main approaches to generalization: instance-based learning and model-based learning.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Instance-Based Versus Model-Based Learning**",
        "page": "15",
        "chunk_id": "chk_08432b71-26dd-4ece-9f91-b39288bf70db",
        "chunk_size": 85,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Instance-based learning**  \nPossibly the most trivial form of learning is simply to learn by heart. If you were to create a spam filter this way, it would just flag all emails that are identical to emails that have already been flagged by users—not the worst solution, but certainly not the best.  \nInstead of just flagging emails that are identical to known spam emails, your spam filter could be programmed to also flag emails that are very similar to known spam emails. This requires a *measure of similarity* between two emails. A (very basic) simi‐ larity measure between two emails could be to count the number of words they have in common. The system would flag an email as spam if it has many words in com‐ mon with a known spam email.  \nThis is called *instance-based learning*: the system learns the examples by heart, then generalizes to new cases by comparing them to the learned examples (or a subset of them), using a similarity measure. For example, in [Figure 1-15](#page-16-0) the new instance would be classified as a triangle because the majority of the most similar instances belong to that class.  \n{16}------------------------------------------------  \n<span id=\"page-16-0\"></span>![](_page_16_Figure_0.jpeg)  \n*Figure 1-15. Instance-based learning*",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Instance-based learning**",
        "page": "15-16",
        "chunk_id": "chk_eeda6ad9-57c4-4f45-b17a-850c7ee826b0",
        "chunk_size": 199,
        "chunk_img_path": "_page_16_Figure_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_16_Figure_0.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Model-based learning**  \nAnother way to generalize from a set of examples is to build a model of these exam‐ ples, then use that model to make *predictions*. This is called *model-based learning* (Figure 1-16).  \n![](_page_16_Figure_4.jpeg)  \n*Figure 1-16. Model-based learning*  \nFor example, suppose you want to know if money makes people happy, so you down‐ load the *Better Life Index* data from the [OECD's website](https://homl.info/4) as well as stats about GDP per capita from the [IMF's website](https://homl.info/5). Then you join the tables and sort by GDP per cap‐ ita. [Table 1-1](#page-17-0) shows an excerpt of what you get.  \n{17}------------------------------------------------  \n<span id=\"page-17-0\"></span>*Table 1-1. Does money make people happier?*  \n| Country       | GDP per capita (USD) | Life satisfaction |\n|---------------|----------------------|-------------------|\n| Hungary       | 12,240               | 4.9               |\n| Korea         | 27,195               | 5.8               |\n| France        | 37,675               | 6.5               |\n| Australia     | 50,962               | 7.3               |\n| United States | 55,805               | 7.2               |  \nLet's plot the data for a few random countries (Figure 1-17).  \n![](_page_17_Figure_3.jpeg)  \n*Figure 1-17. Do you see a trend here?*  \nThere does seem to be a trend here! Although the data is *noisy* (i.e., partly random), it looks like life satisfaction goes up more or less linearly as the country's GDP per cap‐ ita increases. So you decide to model life satisfaction as a linear function of GDP per capita. This step is called *model selection*: you selected a *linear model* of life satisfac‐ tion with just one attribute, GDP per capita (Equation 1-1).  \n*Equation 1-1. A simple linear model*  \nlife\\_satisfaction =\n$$\\theta_0 + \\theta_1 \\times \\text{GDP\\_per\\_capita}$$  \nThis model has two *model parameters*, *θ*<sup>0</sup> and *θ*<sup>1</sup> . <sup>5</sup> By tweaking these parameters, you can make your model represent any linear function, as shown in [Figure 1-18](#page-18-0).  \n<sup>5</sup> By convention, the Greek letter θ (theta) is frequently used to represent model parameters.  \n{18}------------------------------------------------  \n<span id=\"page-18-0\"></span>![](_page_18_Figure_0.jpeg)  \n*Figure 1-18. A few possible linear models*  \nBefore you can use your model, you need to define the parameter values *θ*<sup>0</sup> and *θ*<sup>1</sup> . How can you know which values will make your model perform best? To answer this question, you need to specify a performance measure. You can either define a *utility function* (or *fitness function*) that measures how *good* your model is, or you can define a *cost function* that measures how *bad* it is. For linear regression problems, people typically use a cost function that measures the distance between the linear model's predictions and the training examples; the objective is to minimize this distance.  \nThis is where the Linear Regression algorithm comes in: you feed it your training examples and it finds the parameters that make the linear model fit best to your data. This is called *training* the model. In our case the algorithm finds that the optimal parameter values are *θ*<sup>0</sup> = 4.85 and *θ*<sup>1</sup> = 4.91 × 10–5 .  \nNow the model fits the training data as closely as possible (for a linear model), as you can see in Figure 1-19.  \n![](_page_18_Figure_5.jpeg)  \n*Figure 1-19. The linear model that fits the training data best*  \n{19}------------------------------------------------  \nYou are finally ready to run the model to make predictions. For example, say you want to know how happy Cypriots are, and the OECD data does not have the answer. Fortunately, you can use your model to make a good prediction: you look up Cyprus's GDP per capita, find \\$22,587, and then apply your model and find that life satisfac‐ tion is likely to be somewhere around 4.85 + 22,587 × 4.91 × 10-5 = 5.96.  \nTo whet your appetite, Example 1-1 shows the Python code that loads the data, pre‐ pares it,<sup>6</sup> creates a scatterplot for visualization, and then trains a linear model and makes a prediction.<sup>7</sup>  \n*Example 1-1. Training and running a linear model using Scikit-Learn*  \n```\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport sklearn.linear_model\n# Load the data\noecd_bli = pd.read_csv(\"oecd_bli_2015.csv\", thousands=',')\ngdp_per_capita = pd.read_csv(\"gdp_per_capita.csv\",thousands=',',delimiter='\\t',\nencoding='latin1', na_values=\"n/a\")\n# Prepare the data\ncountry_stats = prepare_country_stats(oecd_bli, gdp_per_capita)\nX = np.c_[country_stats[\"GDP per capita\"]]\ny = np.c_[country_stats[\"Life satisfaction\"]]\n# Visualize the data\ncountry_stats.plot(kind='scatter', x=\"GDP per capita\", y='Life satisfaction')\nplt.show()\n# Select a linear model\nmodel = sklearn.linear_model.LinearRegression()\n# Train the model\nmodel.fit(X, y)\n# Make a prediction for Cyprus\nX_new = [[22587]] # Cyprus' GDP per capita\nprint(model.predict(X_new)) # outputs [[ 5.96242338]]\n```  \n<sup>6</sup> The prepare\\_country\\_stats() function's definition is not shown here (see this chapter's Jupyter notebook if you want all the gory details). It's just boring Pandas code that joins the life satisfaction data from the OECD with the GDP per capita data from the IMF.  \n<sup>7</sup> It's okay if you don't understand all the code yet; we will present Scikit-Learn in the following chapters.  \n{20}------------------------------------------------  \n![](_page_20_Picture_0.jpeg)  \nIf you had used an instance-based learning algorithm instead, you would have found that Slovenia has the closest GDP per capita to that of Cyprus (\\$20,732), and since the OECD data tells us that Slovenians' life satisfaction is 5.7, you would have predicted a life satisfaction of 5.7 for Cyprus. If you zoom out a bit and look at the two next closest countries, you will find Portugal and Spain with life satisfactions of 5.1 and 6.5, respectively. Averaging these three values, you get 5.77, which is pretty close to your model-based pre‐ diction. This simple algorithm is called *k-Nearest Neighbors* regres‐ sion (in this example, *k* = 3).  \nReplacing the Linear Regression model with k-Nearest Neighbors regression in the previous code is as simple as replacing these two lines:  \n```\nimport sklearn.linear_model\nmodel = sklearn.linear_model.LinearRegression()\nwith these two:\nimport sklearn.neighbors\nmodel = sklearn.neighbors.KNeighborsRegressor(n_neighbors=3)\n```  \nIf all went well, your model will make good predictions. If not, you may need to use more attributes (employment rate, health, air pollution, etc.), get more or better qual‐ ity training data, or perhaps select a more powerful model (e.g., a Polynomial Regres‐ sion model).",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Model-based learning**",
        "page": "16-20",
        "chunk_id": "chk_11309513-a12b-4e60-8b8b-10b4979598d5",
        "chunk_size": 974,
        "chunk_img_path": "_page_16_Figure_4.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_16_Figure_4.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### In summary:  \n- You studied the data.\n- You selected a model.\n- You trained it on the training data (i.e., the learning algorithm searched for the model parameter values that minimize a cost function).\n- Finally, you applied the model to make predictions on new cases (this is called *inference*), hoping that this model will generalize well.  \nThis is what a typical Machine Learning project looks like. In [Chapter 2](#page-34-0) you will experience this first-hand by going through an end-to-end project.  \nWe have covered a lot of ground so far: you now know what Machine Learning is really about, why it is useful, what some of the most common categories of ML sys‐ tems are, and what a typical project workflow looks like. Now let's look at what can go wrong in learning and prevent you from making accurate predictions.  \n{21}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "In summary:",
        "page": "20-21",
        "chunk_id": "chk_deff003c-1adb-45b6-84bc-0253f0b5291f",
        "chunk_size": 143,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Main Challenges of Machine Learning**  \nIn short, since your main task is to select a learning algorithm and train it on some data, the two things that can go wrong are \"bad algorithm\" and \"bad data.\" Let's start with examples of bad data.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Main Challenges of Machine Learning**",
        "page": "21",
        "chunk_id": "chk_8e08f3e6-1b30-4157-bff1-bb557b2e50ed",
        "chunk_size": 44,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Insufficient Quantity of Training Data**  \nFor a toddler to learn what an apple is, all it takes is for you to point to an apple and say \"apple\" (possibly repeating this procedure a few times). Now the child is able to recognize apples in all sorts of colors and shapes. Genius.  \nMachine Learning is not quite there yet; it takes a lot of data for most Machine Learn‐ ing algorithms to work properly. Even for very simple problems you typically need thousands of examples, and for complex problems such as image or speech recogni‐ tion you may need millions of examples (unless you can reuse parts of an existing model).  \n{22}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Insufficient Quantity of Training Data**",
        "page": "21-22",
        "chunk_id": "chk_6e1a8977-6f75-4e41-a9c3-20cbb10fb0f0",
        "chunk_size": 112,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **The Unreasonable Effectiveness of Data**  \nIn a [famous paper](https://homl.info/6) published in 2001, Microsoft researchers Michele Banko and Eric Brill showed that very different Machine Learning algorithms, including fairly simple ones, performed almost identically well on a complex problem of natural language disambiguation<sup>8</sup> once they were given enough data (as you can see in Figure 1-20).  \n![](_page_22_Figure_2.jpeg)  \n*Figure 1-20. The importance of data versus algorithms<sup>9</sup>*  \nAs the authors put it: \"these results suggest that we may want to reconsider the tradeoff between spending time and money on algorithm development versus spending it on corpus development.\"  \nThe idea that data matters more than algorithms for complex problems was further popularized by Peter Norvig et al. in a paper titled [\"The Unreasonable Effectiveness](https://homl.info/7) [of Data\"](https://homl.info/7) published in 2009.10 It should be noted, however, that small- and mediumsized datasets are still very common, and it is not always easy or cheap to get extra training data, so don't abandon algorithms just yet.  \n<sup>8</sup> For example, knowing whether to write \"to,\" \"two,\" or \"too\" depending on the context.  \n<sup>9</sup> Figure reproduced with permission from Banko and Brill (2001), \"Learning Curves for Confusion Set Disam‐ biguation.\"  \n<sup>10</sup> \"The Unreasonable Effectiveness of Data,\" Peter Norvig et al. (2009).  \n{23}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**The Unreasonable Effectiveness of Data**",
        "page": "22-23",
        "chunk_id": "chk_91934077-6f6f-4377-9599-ead551439635",
        "chunk_size": 203,
        "chunk_img_path": "_page_22_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_22_Figure_2.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Nonrepresentative Training Data**  \nIn order to generalize well, it is crucial that your training data be representative of the new cases you want to generalize to. This is true whether you use instance-based learning or model-based learning.  \nFor example, the set of countries we used earlier for training the linear model was not perfectly representative; a few countries were missing. Figure 1-21 shows what the data looks like when you add the missing countries.  \n![](_page_23_Figure_3.jpeg)  \n*Figure 1-21. A more representative training sample*  \nIf you train a linear model on this data, you get the solid line, while the old model is represented by the dotted line. As you can see, not only does adding a few missing countries significantly alter the model, but it makes it clear that such a simple linear model is probably never going to work well. It seems that very rich countries are not happier than moderately rich countries (in fact they seem unhappier), and conversely some poor countries seem happier than many rich countries.  \nBy using a nonrepresentative training set, we trained a model that is unlikely to make accurate predictions, especially for very poor and very rich countries.  \nIt is crucial to use a training set that is representative of the cases you want to general‐ ize to. This is often harder than it sounds: if the sample is too small, you will have *sampling noise* (i.e., nonrepresentative data as a result of chance), but even very large samples can be nonrepresentative if the sampling method is flawed. This is called *sampling bias*.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Nonrepresentative Training Data**",
        "page": "23",
        "chunk_id": "chk_fd07419f-17fd-4e20-97d8-8d735d7b95e3",
        "chunk_size": 260,
        "chunk_img_path": "_page_23_Figure_3.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_23_Figure_3.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **A Famous Example of Sampling Bias**  \nPerhaps the most famous example of sampling bias happened during the US presi‐ dential election in 1936, which pitted Landon against Roosevelt: the *Literary Digest* conducted a very large poll, sending mail to about 10 million people. It got 2.4 million answers, and predicted with high confidence that Landon would get 57% of the votes.  \n{24}------------------------------------------------  \nInstead, Roosevelt won with 62% of the votes. The flaw was in the *Literary Digest*'s sampling method:  \n- First, to obtain the addresses to send the polls to, the *Literary Digest* used tele‐ phone directories, lists of magazine subscribers, club membership lists, and the like. All of these lists tend to favor wealthier people, who are more likely to vote Republican (hence Landon).\n- Second, less than 25% of the people who received the poll answered. Again, this introduces a sampling bias, by ruling out people who don't care much about poli‐ tics, people who don't like the *Literary Digest*, and other key groups. This is a spe‐ cial type of sampling bias called *nonresponse bias*.  \nHere is another example: say you want to build a system to recognize funk music vid‐ eos. One way to build your training set is to search \"funk music\" on YouTube and use the resulting videos. But this assumes that YouTube's search engine returns a set of videos that are representative of all the funk music videos on YouTube. In reality, the search results are likely to be biased toward popular artists (and if you live in Brazil you will get a lot of \"funk carioca\" videos, which sound nothing like James Brown). On the other hand, how else can you get a large training set?",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**A Famous Example of Sampling Bias**",
        "page": "23-24",
        "chunk_id": "chk_e650559b-258e-437c-a068-d45a5d480ee6",
        "chunk_size": 285,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Poor-Quality Data**  \nObviously, if your training data is full of errors, outliers, and noise (e.g., due to poorquality measurements), it will make it harder for the system to detect the underlying patterns, so your system is less likely to perform well. It is often well worth the effort to spend time cleaning up your training data. The truth is, most data scientists spend a significant part of their time doing just that. For example:  \n- If some instances are clearly outliers, it may help to simply discard them or try to fix the errors manually.\n- If some instances are missing a few features (e.g., 5% of your customers did not specify their age), you must decide whether you want to ignore this attribute alto‐ gether, ignore these instances, fill in the missing values (e.g., with the median age), or train one model with the feature and one model without it, and so on.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Poor-Quality Data**",
        "page": "24",
        "chunk_id": "chk_f807291a-ee07-4be8-9225-1cdfd55615f3",
        "chunk_size": 155,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Irrelevant Features**  \nAs the saying goes: garbage in, garbage out. Your system will only be capable of learn‐ ing if the training data contains enough relevant features and not too many irrelevant ones. A critical part of the success of a Machine Learning project is coming up with a good set of features to train on. This process, called *feature engineering*, involves:  \n{25}------------------------------------------------  \n- *Feature selection*: selecting the most useful features to train on among existing features.\n- *Feature extraction*: combining existing features to produce a more useful one (as we saw earlier, dimensionality reduction algorithms can help).\n- Creating new features by gathering new data.  \nNow that we have looked at many examples of bad data, let's look at a couple of exam‐ ples of bad algorithms.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Irrelevant Features**",
        "page": "24-25",
        "chunk_id": "chk_ceced216-8255-459e-9aa6-4f031bb28451",
        "chunk_size": 129,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Overtting the Training Data**  \nSay you are visiting a foreign country and the taxi driver rips you off. You might be tempted to say that *all* taxi drivers in that country are thieves. Overgeneralizing is something that we humans do all too often, and unfortunately machines can fall into the same trap if we are not careful. In Machine Learning this is called *overfitting*: it means that the model performs well on the training data, but it does not generalize well.  \nFigure 1-22 shows an example of a high-degree polynomial life satisfaction model that strongly overfits the training data. Even though it performs much better on the training data than the simple linear model, would you really trust its predictions?  \n![](_page_25_Figure_7.jpeg)  \n*Figure 1-22. Overfitting the training data*  \nComplex models such as deep neural networks can detect subtle patterns in the data, but if the training set is noisy, or if it is too small (which introduces sampling noise), then the model is likely to detect patterns in the noise itself. Obviously these patterns will not generalize to new instances. For example, say you feed your life satisfaction model many more attributes, including uninformative ones such as the country's name. In that case, a complex model may detect patterns like the fact that all coun‐ tries in the training data with a *w* in their name have a life satisfaction greater than 7: New Zealand (7.3), Norway (7.4), Sweden (7.2), and Switzerland (7.5). How confident  \n{26}------------------------------------------------  \nare you that the W-satisfaction rule generalizes to Rwanda or Zimbabwe? Obviously this pattern occurred in the training data by pure chance, but the model has no way to tell whether a pattern is real or simply the result of noise in the data.  \n![](_page_26_Picture_1.jpeg)  \nOverfitting happens when the model is too complex relative to the amount and noisiness of the training data. The possible solutions are:  \n- To simplify the model by selecting one with fewer parameters (e.g., a linear model rather than a high-degree polynomial model), by reducing the number of attributes in the training data or by constraining the model\n- To gather more training data\n- To reduce the noise in the training data (e.g., fix data errors and remove outliers)  \nConstraining a model to make it simpler and reduce the risk of overfitting is called *regularization*. For example, the linear model we defined earlier has two parameters, *θ*0 and *θ*<sup>1</sup> . This gives the learning algorithm two *degrees of freedom* to adapt the model to the training data: it can tweak both the height (*θ*<sup>0</sup> ) and the slope (*θ*<sup>1</sup> ) of the line. If we forced *θ*<sup>1</sup> = 0, the algorithm would have only one degree of freedom and would have a much harder time fitting the data properly: all it could do is move the line up or down to get as close as possible to the training instances, so it would end up around the mean. A very simple model indeed! If we allow the algorithm to modify *θ*<sup>1</sup> but we force it to keep it small, then the learning algorithm will effectively have some‐ where in between one and two degrees of freedom. It will produce a simpler model than with two degrees of freedom, but more complex than with just one. You want to find the right balance between fitting the training data perfectly and keeping the model simple enough to ensure that it will generalize well.  \n[Figure 1-23](#page-27-0) shows three models: the dotted line represents the original model that was trained with a few countries missing, the dashed line is our second model trained with all countries, and the solid line is a linear model trained with the same data as the first model but with a regularization constraint. You can see that regularization forced the model to have a smaller slope, which fits a bit less the training data that the model was trained on, but actually allows it to generalize better to new examples.  \n{27}------------------------------------------------  \n<span id=\"page-27-0\"></span>![](_page_27_Figure_0.jpeg)  \n*Figure 1-23. Regularization reduces the risk of overfitting*  \nThe amount of regularization to apply during learning can be controlled by a *hyper‐ parameter*. A hyperparameter is a parameter of a learning algorithm (not of the model). As such, it is not affected by the learning algorithm itself; it must be set prior to training and remains constant during training. If you set the regularization hyper‐ parameter to a very large value, you will get an almost flat model (a slope close to zero); the learning algorithm will almost certainly not overfit the training data, but it will be less likely to find a good solution. Tuning hyperparameters is an important part of building a Machine Learning system (you will see a detailed example in the next chapter).",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Overtting the Training Data**",
        "page": "25-27",
        "chunk_id": "chk_588c4c78-e997-4b80-a860-87ca90355ca2",
        "chunk_size": 793,
        "chunk_img_path": "_page_25_Figure_7.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_25_Figure_7.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Undertting the Training Data**  \nAs you might guess, *underfitting* is the opposite of overfitting: it occurs when your model is too simple to learn the underlying structure of the data. For example, a lin‐ ear model of life satisfaction is prone to underfit; reality is just more complex than the model, so its predictions are bound to be inaccurate, even on the training exam‐ ples.  \nThe main options to fix this problem are:  \n- Selecting a more powerful model, with more parameters\n- Feeding better features to the learning algorithm (feature engineering)\n- Reducing the constraints on the model (e.g., reducing the regularization hyper‐ parameter)",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Undertting the Training Data**",
        "page": "27",
        "chunk_id": "chk_7780de25-8e31-4805-abaa-c12f8a34b394",
        "chunk_size": 106,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Stepping Back**  \nBy now you already know a lot about Machine Learning. However, we went through so many concepts that you may be feeling a little lost, so let's step back and look at the big picture:  \n{28}------------------------------------------------  \n- Machine Learning is about making machines get better at some task by learning from data, instead of having to explicitly code rules.\n- There are many different types of ML systems: supervised or not, batch or online, instance-based or model-based, and so on.\n- In a ML project you gather data in a training set, and you feed the training set to a learning algorithm. If the algorithm is model-based it tunes some parameters to fit the model to the training set (i.e., to make good predictions on the training set itself), and then hopefully it will be able to make good predictions on new cases as well. If the algorithm is instance-based, it just learns the examples by heart and generalizes to new instances by comparing them to the learned instances using a similarity measure.\n- The system will not perform well if your training set is too small, or if the data is not representative, noisy, or polluted with irrelevant features (garbage in, garbage out). Lastly, your model needs to be neither too simple (in which case it will underfit) nor too complex (in which case it will overfit).  \nThere's just one last important topic to cover: once you have trained a model, you don't want to just \"hope\" it generalizes to new cases. You want to evaluate it, and finetune it if necessary. Let's see how.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Stepping Back**",
        "page": "27-28",
        "chunk_id": "chk_d13c0c0e-a173-434c-af6b-b83ad22c100f",
        "chunk_size": 269,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Testing and Validating**  \nThe only way to know how well a model will generalize to new cases is to actually try it out on new cases. One way to do that is to put your model in production and moni‐ tor how well it performs. This works well, but if your model is horribly bad, your users will complain—not the best idea.  \nA better option is to split your data into two sets: the *training set* and the *test set*. As these names imply, you train your model using the training set, and you test it using the test set. The error rate on new cases is called the *generalization error* (or *out-ofsample error*), and by evaluating your model on the test set, you get an estimate of this error. This value tells you how well your model will perform on instances it has never seen before.  \nIf the training error is low (i.e., your model makes few mistakes on the training set) but the generalization error is high, it means that your model is overfitting the train‐ ing data.  \n![](_page_28_Picture_9.jpeg)  \nIt is common to use 80% of the data for training and *hold out* 20% for testing. However, this depends on the size of the dataset: if it contains 10 million instances, then holding out 1% means your test set will contain 100,000 instances: that's probably more than enough to get a good estimate of the generalization error.  \n{29}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Testing and Validating**",
        "page": "28-29",
        "chunk_id": "chk_1238b418-66bc-4e6a-a1d0-04f67cafdc0c",
        "chunk_size": 241,
        "chunk_img_path": "_page_28_Picture_9.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_28_Picture_9.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Hyperparameter Tuning and Model Selection**  \nSo evaluating a model is simple enough: just use a test set. Now suppose you are hesi‐ tating between two models (say a linear model and a polynomial model): how can you decide? One option is to train both and compare how well they generalize using the test set.  \nNow suppose that the linear model generalizes better, but you want to apply some regularization to avoid overfitting. The question is: how do you choose the value of the regularization hyperparameter? One option is to train 100 different models using 100 different values for this hyperparameter. Suppose you find the best hyperparame‐ ter value that produces a model with the lowest generalization error, say just 5% error.  \nSo you launch this model into production, but unfortunately it does not perform as well as expected and produces 15% errors. What just happened?  \nThe problem is that you measured the generalization error multiple times on the test set, and you adapted the model and hyperparameters to produce the best model *for that particular set*. This means that the model is unlikely to perform as well on new data.  \nA common solution to this problem is called *holdout validation*: you simply hold out part of the training set to evaluate several candidate models and select the best one. The new heldout set is called the *validation set* (or sometimes the *development set*, or *dev set*). More specifically, you train multiple models with various hyperparameters on the reduced training set (i.e., the full training set minus the validation set), and you select the model that performs best on the validation set. After this holdout vali‐ dation process, you train the best model on the full training set (including the valida‐ tion set), and this gives you the final model. Lastly, you evaluate this final model on the test set to get an estimate of the generalization error.  \nThis solution usually works quite well. However, if the validation set is too small, then model evaluations will be imprecise: you may end up selecting a suboptimal model by mistake. Conversely, if the validation set is too large, then the remaining training set will be much smaller than the full training set. Why is this bad? Well, since the final model will be trained on the full training set, it is not ideal to compare candidate models trained on a much smaller training set. It would be like selecting the fastest sprinter to participate in a marathon. One way to solve this problem is to perform repeated *cross-validation*, using many small validation sets. Each model is evaluated once per validation set, after it is trained on the rest of the data. By averaging out all the evaluations of a model, we get a much more accurate measure of its performance. However, there is a drawback: the training time is multiplied by the number of valida‐ tion sets.  \n{30}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Hyperparameter Tuning and Model Selection**",
        "page": "29-30",
        "chunk_id": "chk_50c448aa-cb60-49f9-88f6-e48e194f647f",
        "chunk_size": 486,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Data Mismatch**  \nIn some cases, it is easy to get a large amount of data for training, but it is not per‐ fectly representative of the data that will be used in production. For example, suppose you want to create a mobile app to take pictures of flowers and automatically deter‐ mine their species. You can easily download millions of pictures of flowers on the web, but they won't be perfectly representative of the pictures that will actually be taken using the app on a mobile device. Perhaps you only have 10,000 representative pictures (i.e., actually taken with the app). In this case, the most important rule to remember is that the validation set and the test must be as representative as possible of the data you expect to use in production, so they should be composed exclusively of representative pictures: you can shuffle them and put half in the validation set, and half in the test set (making sure that no duplicates or near-duplicates end up in both sets). After training your model on the web pictures, if you observe that the perfor‐ mance of your model on the validation set is disappointing, you will not know whether this is because your model has overfit the training set, or whether this is just due to the mismatch between the web pictures and the mobile app pictures. One sol‐ ution is to hold out part of the training pictures (from the web) in yet another set that Andrew Ng calls the *train-dev set*. After the model is trained (on the training set, *not* on the train-dev set), you can evaluate it on the train-dev set: if it performs well, then the model is not overfitting the training set, so if performs poorly on the validation set, the problem must come from the data mismatch. You can try to tackle this prob‐ lem by preprocessing the web images to make them look more like the pictures that will be taken by the mobile app, and then retraining the model. Conversely, if the model performs poorly on the train-dev set, then the model must have overfit the training set, so you should try to simplify or regularize the model, get more training data and clean up the training data, as discussed earlier.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Data Mismatch**",
        "page": "30",
        "chunk_id": "chk_6f6bfaef-f255-44b0-943c-db47b962c9cf",
        "chunk_size": 381,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **No Free Lunch Theorem**  \nA model is a simplified version of the observations. The simplifications are meant to discard the superfluous details that are unlikely to generalize to new instances. How‐ ever, to decide what data to discard and what data to keep, you must make *assump‐ tions*. For example, a linear model makes the assumption that the data is fundamentally linear and that the distance between the instances and the straight line is just noise, which can safely be ignored.  \nIn a [famous 1996 paper](https://homl.info/8), <sup>11</sup> David Wolpert demonstrated that if you make absolutely no assumption about the data, then there is no reason to prefer one model over any other. This is called the *No Free Lunch* (NFL) theorem. For some datasets the best  \n<sup>11</sup> \"The Lack of A Priori Distinctions Between Learning Algorithms,\" D. Wolpert (1996).  \n{31}------------------------------------------------  \nmodel is a linear model, while for other datasets it is a neural network. There is no model that is *a priori* guaranteed to work better (hence the name of the theorem). The only way to know for sure which model is best is to evaluate them all. Since this is not possible, in practice you make some reasonable assumptions about the data and you evaluate only a few reasonable models. For example, for simple tasks you may evalu‐ ate linear models with various levels of regularization, and for a complex problem you may evaluate various neural networks.",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**No Free Lunch Theorem**",
        "page": "30-31",
        "chunk_id": "chk_8ff57208-d716-4bf2-9b38-a4003486f570",
        "chunk_size": 239,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Exercises**  \nIn this chapter we have covered some of the most important concepts in Machine Learning. In the next chapters we will dive deeper and write more code, but before we do, make sure you know how to answer the following questions:  \n- 1. How would you define Machine Learning?\n- 2. Can you name four types of problems where it shines?\n- 3. What is a labeled training set?\n- 4. What are the two most common supervised tasks?\n- 5. Can you name four common unsupervised tasks?\n- 6. What type of Machine Learning algorithm would you use to allow a robot to walk in various unknown terrains?\n- 7. What type of algorithm would you use to segment your customers into multiple groups?\n- 8. Would you frame the problem of spam detection as a supervised learning prob‐ lem or an unsupervised learning problem?\n- 9. What is an online learning system?\n- 10. What is out-of-core learning?\n- 11. What type of learning algorithm relies on a similarity measure to make predic‐ tions?\n- 12. What is the difference between a model parameter and a learning algorithm's hyperparameter?\n- 13. What do model-based learning algorithms search for? What is the most common strategy they use to succeed? How do they make predictions?\n- 14. Can you name four of the main challenges in Machine Learning?\n- 15. If your model performs great on the training data but generalizes poorly to new instances, what is happening? Can you name three possible solutions?\n- 16. What is a test set and why would you want to use it?  \n{32}------------------------------------------------  \n- 17. What is the purpose of a validation set?\n- 18. What can go wrong if you tune hyperparameters using the test set?\n- 19. What is repeated cross-validation and why would you prefer it to using a single validation set?  \nSolutions to these exercises are available in ???.  \n{33}------------------------------------------------  \n{34}------------------------------------------------",
      "metadata": {
        "header": "**The Machine Learning Landscape**",
        "subheader": "**Exercises**",
        "page": "31-34",
        "chunk_id": "chk_a78737b0-9440-40e0-9775-5d3bb9955d80",
        "chunk_size": 324,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# <span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**  \n![](_page_34_Picture_2.jpeg)  \nWith Early Release ebooks, you get books in their earliest form the author's raw and unedited content as he or she writes—so you can take advantage of these technologies long before the official release of these titles. The following will be Chapter 2 in the final release of the book.  \nIn this chapter, you will go through an example project end to end, pretending to be a recently hired data scientist in a real estate company.<sup>1</sup> Here are the main steps you will go through:  \n- 1. Look at the big picture.\n- 2. Get the data.\n- 3. Discover and visualize the data to gain insights.\n- 4. Prepare the data for Machine Learning algorithms.\n- 5. Select a model and train it.\n- 6. Fine-tune your model.\n- 7. Present your solution.\n- 8. Launch, monitor, and maintain your system.  \n<sup>1</sup> The example project is completely fictitious; the goal is just to illustrate the main steps of a Machine Learning project, not to learn anything about the real estate business.  \n{35}------------------------------------------------",
      "metadata": {
        "header": "<span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**",
        "subheader": null,
        "page": "34-35",
        "chunk_id": "chk_6d98c098-3bfc-474c-8530-719b924cdb52",
        "chunk_size": 180,
        "chunk_img_path": "_page_34_Picture_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_34_Picture_2.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Working with Real Data**  \nWhen you are learning about Machine Learning it is best to actually experiment with real-world data, not just artificial datasets. Fortunately, there are thousands of open datasets to choose from, ranging across all sorts of domains. Here are a few places you can look to get data:  \n- Popular open data repositories:\n- [UC Irvine Machine Learning Repository](http://archive.ics.uci.edu/ml/)\n- [Kaggle datasets](https://www.kaggle.com/datasets)\n- [Amazon's AWS datasets](https://registry.opendata.aws/)\n- Meta portals (they list open data repositories):\n- *<http://dataportals.org/>*\n- *<http://opendatamonitor.eu/>*\n- *<http://quandl.com/>*\n- Other pages listing many popular open data repositories:\n- [Wikipedia's list of Machine Learning datasets](https://homl.info/9)\n- [Quora.com question](https://homl.info/10)\n- [Datasets subreddit](https://www.reddit.com/r/datasets)  \nIn this chapter we chose the California Housing Prices dataset from the StatLib repos‐ itory<sup>2</sup> (see [Figure 2-1\\)](#page-36-0). This dataset was based on data from the 1990 California cen‐ sus. It is not exactly recent (you could still afford a nice house in the Bay Area at the time), but it has many qualities for learning, so we will pretend it is recent data. We also added a categorical attribute and removed a few features for teaching purposes.  \n<sup>2</sup> The original dataset appeared in R. Kelley Pace and Ronald Barry, \"Sparse Spatial Autoregressions,\" *Statistics & Probability Letters* 33, no. 3 (1997): 291–297.  \n{36}------------------------------------------------  \n<span id=\"page-36-0\"></span>![](_page_36_Figure_0.jpeg)  \n*Figure 2-1. California housing prices*",
      "metadata": {
        "header": "<span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**",
        "subheader": "**Working with Real Data**",
        "page": "35-36",
        "chunk_id": "chk_fa02b36e-b1da-4216-86e6-6b0bb512526a",
        "chunk_size": 216,
        "chunk_img_path": "_page_36_Figure_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_36_Figure_0.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Look at the Big Picture**  \nWelcome to Machine Learning Housing Corporation! The first task you are asked to perform is to build a model of housing prices in California using the California cen‐ sus data. This data has metrics such as the population, median income, median hous‐ ing price, and so on for each block group in California. Block groups are the smallest geographical unit for which the US Census Bureau publishes sample data (a block group typically has a population of 600 to 3,000 people). We will just call them \"dis‐ tricts\" for short.  \nYour model should learn from this data and be able to predict the median housing price in any district, given all the other metrics.  \n![](_page_36_Picture_5.jpeg)  \nSince you are a well-organized data scientist, the first thing you do is to pull out your Machine Learning project checklist. You can start with the one in ???; it should work reasonably well for most Machine Learning projects but make sure to adapt it to your needs. In this chapter we will go through many checklist items, but we will also skip a few, either because they are self-explanatory or because they will be discussed in later chapters.",
      "metadata": {
        "header": "<span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**",
        "subheader": "**Look at the Big Picture**",
        "page": "36",
        "chunk_id": "chk_be36df36-4f2e-42a2-b473-8da334afc849",
        "chunk_size": 200,
        "chunk_img_path": "_page_36_Picture_5.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_36_Picture_5.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Frame the Problem**  \nThe first question to ask your boss is what exactly is the business objective; building a model is probably not the end goal. How does the company expect to use and benefit  \n{37}------------------------------------------------  \nfrom this model? This is important because it will determine how you frame the problem, what algorithms you will select, what performance measure you will use to evaluate your model, and how much effort you should spend tweaking it.  \nYour boss answers that your model's output (a prediction of a district's median hous‐ ing price) will be fed to another Machine Learning system (see Figure 2-2), along with many other *signals*. <sup>3</sup> This downstream system will determine whether it is worth investing in a given area or not. Getting this right is critical, as it directly affects reve‐ nue.  \n![](_page_37_Figure_2.jpeg)  \n*Figure 2-2. A Machine Learning pipeline for real estate investments*",
      "metadata": {
        "header": "<span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**",
        "subheader": "**Frame the Problem**",
        "page": "36-37",
        "chunk_id": "chk_58badf7d-494e-4d2f-9902-68a07f393722",
        "chunk_size": 147,
        "chunk_img_path": "_page_37_Figure_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_37_Figure_2.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Pipelines**  \nA sequence of data processing *components* is called a data *pipeline*. Pipelines are very common in Machine Learning systems, since there is a lot of data to manipulate and many data transformations to apply.  \nComponents typically run asynchronously. Each component pulls in a large amount of data, processes it, and spits out the result in another data store, and then some time later the next component in the pipeline pulls this data and spits out its own output, and so on. Each component is fairly self-contained: the interface between components is simply the data store. This makes the system quite simple to grasp (with the help of a data flow graph), and different teams can focus on different components. Moreover, if a component breaks down, the downstream components can often continue to run normally (at least for a while) by just using the last output from the broken compo‐ nent. This makes the architecture quite robust.  \n<sup>3</sup> A piece of information fed to a Machine Learning system is often called a *signal* in reference to Shannon's information theory: you want a high signal/noise ratio.  \n{38}------------------------------------------------  \nOn the other hand, a broken component can go unnoticed for some time if proper monitoring is not implemented. The data gets stale and the overall system's perfor‐ mance drops.  \nThe next question to ask is what the current solution looks like (if any). It will often give you a reference performance, as well as insights on how to solve the problem. Your boss answers that the district housing prices are currently estimated manually by experts: a team gathers up-to-date information about a district, and when they cannot get the median housing price, they estimate it using complex rules.  \nThis is costly and time-consuming, and their estimates are not great; in cases where they manage to find out the actual median housing price, they often realize that their estimates were off by more than 20%. This is why the company thinks that it would be useful to train a model to predict a district's median housing price given other data about that district. The census data looks like a great dataset to exploit for this pur‐ pose, since it includes the median housing prices of thousands of districts, as well as other data.  \nOkay, with all this information you are now ready to start designing your system. First, you need to frame the problem: is it supervised, unsupervised, or Reinforce‐ ment Learning? Is it a classification task, a regression task, or something else? Should you use batch learning or online learning techniques? Before you read on, pause and try to answer these questions for yourself.  \nHave you found the answers? Let's see: it is clearly a typical supervised learning task since you are given *labeled* training examples (each instance comes with the expected output, i.e., the district's median housing price). Moreover, it is also a typical regres‐ sion task, since you are asked to predict a value. More specifically, this is a *multiple regression* problem since the system will use multiple features to make a prediction (it will use the district's population, the median income, etc.). It is also a *univariate regression* problem since we are only trying to predict a single value for each district. If we were trying to predict multiple values per district, it would be a *multivariate regression* problem. Finally, there is no continuous flow of data coming in the system, there is no particular need to adjust to changing data rapidly, and the data is small enough to fit in memory, so plain batch learning should do just fine.  \n![](_page_38_Picture_5.jpeg)  \nIf the data was huge, you could either split your batch learning work across multiple servers (using the *MapReduce* technique), or you could use an online learning technique instead.  \n{39}------------------------------------------------",
      "metadata": {
        "header": "<span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**",
        "subheader": "**Pipelines**",
        "page": "37-39",
        "chunk_id": "chk_91aea9ca-a5c7-4876-a727-2525f2c0c6c0",
        "chunk_size": 632,
        "chunk_img_path": "_page_38_Picture_5.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\_page_38_Picture_5.jpeg",
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Select a Performance Measure  \nYour next step is to select a performance measure. A typical performance measure for regression problems is the Root Mean Square Error (RMSE). It gives an idea of how much error the system typically makes in its predictions, with a higher weight for large errors. Equation 2-1 shows the mathematical formula to compute the RMSE.  \nEquation 2-1. Root Mean Square Error (RMSE)  \nRMSE(\n$$\\mathbf{X}, h$$\n) =  $\\sqrt{\\frac{1}{m} \\sum_{i=1}^{m} \\left(h(\\mathbf{x}^{(i)}) - y^{(i)}\\right)^2}$",
      "metadata": {
        "header": "<span id=\"page-34-0\"></span>**End-to-End Machine Learning Project**",
        "subheader": "Select a Performance Measure",
        "page": "39",
        "chunk_id": "chk_82f4ce0c-2b95-4abe-82f9-fdbb95a6ceec",
        "chunk_size": 77,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_745a3d93-23cf-48dc-9e44-999d32a41cb0",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1\\oreilly-p1.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p1",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "{0}------------------------------------------------",
      "metadata": {
        "header": null,
        "subheader": null,
        "page": "0",
        "chunk_id": "chk_4c54f165-ec9e-4a85-b11e-0a9176ecf289",
        "chunk_size": 1,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Select a Performance Measure  \nYour next step is to select a performance measure. A typical performance measure for regression problems is the Root Mean Square Error (RMSE). It gives an idea of how much error the system typically makes in its predictions, with a higher weight for large errors. Equation 2-1 shows the mathematical formula to compute the RMSE.  \nEquation 2-1. Root Mean Square Error (RMSE)  \nRMSE(\n$$\\mathbf{X}, h$$\n) =  $\\sqrt{\\frac{1}{m} \\sum_{i=1}^{m} \\left(h(\\mathbf{x}^{(i)}) - y^{(i)}\\right)^2}$  \n{1}------------------------------------------------",
      "metadata": {
        "header": null,
        "subheader": "Select a Performance Measure",
        "page": "0-1",
        "chunk_id": "chk_17f3c17c-f940-4567-b8c3-a099cbc6d3e5",
        "chunk_size": 78,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Notations**  \nThis equation introduces several very common Machine Learning notations that we will use throughout this book:  \n- *m* is the number of instances in the dataset you are measuring the RMSE on.\n- For example, if you are evaluating the RMSE on a validation set of 2,000 dis‐ tricts, then *m* = 2,000.\n- **x** *(i)* is a vector of all the feature values (excluding the label) of the *i th* instance in the dataset, and *y (i)* is its label (the desired output value for that instance).\n- For example, if the first district in the dataset is located at longitude –118.29°, latitude 33.91°, and it has 1,416 inhabitants with a median income of \\$38,372, and the median house value is \\$156,400 (ignoring the other features for now), then:  \n$$\\mathbf{x}^{(1)} = \\begin{pmatrix} -118.29 \\\\ 33.91 \\\\ 1,416 \\\\ 38,372 \\end{pmatrix}$$  \nand:  \n$$y^{(1)} = 156,400$$  \n- **X** is a matrix containing all the feature values (excluding labels) of all instances in the dataset. There is one row per instance and the *i th* row is equal to the transpose of **x** *(i)*, noted (**x** *(i)*) *T* . 4\n- For example, if the first district is as just described, then the matrix **X** looks like this:  \n$$\\mathbf{X} = \\begin{pmatrix} \\left(\\mathbf{x}^{(1)}\\right)^{T} \\\\ \\left(\\mathbf{x}^{(2)}\\right)^{T} \\\\ \\vdots \\\\ \\left(\\mathbf{x}^{(1999)}\\right)^{T} \\\\ \\left(\\mathbf{x}^{(2000)}\\right)^{T} \\end{pmatrix} = \\begin{pmatrix} -118.29 & 33.91 & 1,416 & 38,372 \\\\ \\vdots & \\vdots & \\vdots & \\vdots \\\\ & \\vdots & \\vdots & \\vdots \\end{pmatrix}$$  \n<sup>4</sup> Recall that the transpose operator flips a column vector into a row vector (and vice versa).  \n{2}------------------------------------------------  \n- *h* is your system's prediction function, also called a *hypothesis*. When your system is given an instance's feature vector  $\\mathbf{x}^{(i)}$ , it outputs a predicted value  $\\hat{\\mathbf{y}}^{(i)} = h(\\mathbf{x}^{(i)})$ for that instance ( $\\hat{y}$  is pronounced \"y-hat\").\n- For example, if your system predicts that the median housing price in the first district is \\$158,400, then  $\\hat{v}^{(1)} = h(\\mathbf{x}^{(1)}) = 158,400$ . The prediction error for this district is  $\\hat{v}^{(1)} - v^{(1)} = 2.000$ .\n- RMSE(X,h) is the cost function measured on the set of examples using your hypothesis *h*.  \nWe use lowercase italic font for scalar values (such as m or  $v^{(i)}$ ) and function names (such as h), lowercase bold font for vectors (such as  $\\mathbf{x}^{(i)}$ ), and uppercase bold font for matrices (such as X).  \nEven though the RMSE is generally the preferred performance measure for regression tasks, in some contexts you may prefer to use another function. For example, suppose that there are many outlier districts. In that case, you may consider using the Mean *Absolute Error* (also called the Average Absolute Deviation; see Equation 2-2):  \nEquation 2-2. Mean Absolute Error  \n$$\\text{MAE}(\\mathbf{X},h) = \\frac{1}{m} \\sum_{i=1}^{m} \\left| h(\\mathbf{x}^{(i)}) - y^{(i)} \\right|$$  \nBoth the RMSE and the MAE are ways to measure the distance between two vectors: the vector of predictions and the vector of target values. Various distance measures, or *norms*, are possible:  \n- Computing the root of a sum of squares (RMSE) corresponds to the Euclidean *norm*: it is the notion of distance you are familiar with. It is also called the  $\\ell_2$ *norm*, noted  $\\|\\cdot\\|_2$  (or just  $\\|\\cdot\\|$ ).\n- Computing the sum of absolutes (MAE) corresponds to the  $\\ell_1$  *norm*, noted  $\\|\\cdot\\|_1$ . It is sometimes called the Manhattan norm because it measures the distance between two points in a city if you can only travel along orthogonal city blocks.\n- More generally, the  $\\ell_k$  norm of a vector **v** containing n elements is defined as  $\\|\\mathbf{v}\\|_{k} = (|v_0|^k + |v_1|^k + \\dots + |v_n|^k)^{\\frac{1}{k}}$ .  $\\ell_0$  just gives the number of non-zero elements in the vector, and  $\\ell_{\\infty}$  gives the maximum absolute value in the vector.\n- The higher the norm index, the more it focuses on large values and neglects small ones. This is why the RMSE is more sensitive to outliers than the MAE. But when  \n{3}------------------------------------------------  \noutliers are exponentially rare (like in a bell-shaped curve), the RMSE performs very well and is generally preferred.",
      "metadata": {
        "header": null,
        "subheader": "**Notations**",
        "page": "1-3",
        "chunk_id": "chk_af58fcef-be2d-457d-adc8-28b8f6ada016",
        "chunk_size": 670,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Check the Assumptions**  \nLastly, it is good practice to list and verify the assumptions that were made so far (by you or others); this can catch serious issues early on. For example, the district prices that your system outputs are going to be fed into a downstream Machine Learning system, and we assume that these prices are going to be used as such. But what if the downstream system actually converts the prices into categories (e.g., \"cheap,\" \"medium,\" or \"expensive\") and then uses those categories instead of the prices them‐ selves? In this case, getting the price perfectly right is not important at all; your sys‐ tem just needs to get the category right. If that's so, then the problem should have been framed as a classification task, not a regression task. You don't want to find this out after working on a regression system for months.  \nFortunately, after talking with the team in charge of the downstream system, you are confident that they do indeed need the actual prices, not just categories. Great! You're all set, the lights are green, and you can start coding now!",
      "metadata": {
        "header": null,
        "subheader": "**Check the Assumptions**",
        "page": "3",
        "chunk_id": "chk_7768035c-a44f-4aaf-9d1d-9f0c0dc794e1",
        "chunk_size": 188,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Get the Data**  \nIt's time to get your hands dirty. Don't hesitate to pick up your laptop and walk through the following code examples in a Jupyter notebook. The full Jupyter note‐ book is available at *<https://github.com/ageron/handson-ml2>*.",
      "metadata": {
        "header": "**Get the Data**",
        "subheader": null,
        "page": "3",
        "chunk_id": "chk_64393555-ae3d-479b-8b3d-89298d8bf688",
        "chunk_size": 38,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Create the Workspace**  \nFirst you will need to have Python installed. It is probably already installed on your system. If not, you can get it at *<https://www.python.org/>*. 5  \nNext you need to create a workspace directory for your Machine Learning code and datasets. Open a terminal and type the following commands (after the \\$ prompts):  \n```\n$ export ML_PATH=\"$HOME/ml\" # You can change the path if you prefer\n$ mkdir -p $ML_PATH\n```  \nYou will need a number of Python modules: Jupyter, NumPy, Pandas, Matplotlib, and Scikit-Learn. If you already have Jupyter running with all these modules installed, you can safely skip to [\"Download the Data\" on page 49](#page-7-0). If you don't have them yet, there are many ways to install them (and their dependencies). You can use your sys‐  \n<sup>5</sup> The latest version of Python 3 is recommended. Python 2.7+ may work too, but it is now deprecated, all major scientific libraries are dropping support for it, so you should migrate to Python 3 as soon as possible.  \n{4}------------------------------------------------  \ntem's packaging system (e.g., apt-get on Ubuntu, or MacPorts or HomeBrew on MacOS), install a Scientific Python distribution such as Anaconda and use its packag‐ ing system, or just use Python's own packaging system, pip, which is included by default with the Python binary installers (since Python 2.7.9).<sup>6</sup> You can check to see if pip is installed by typing the following command:  \n```\n$ python3 -m pip --version\npip 19.0.2 from [...]/lib/python3.6/site-packages (python 3.6)\n```  \nYou should make sure you have a recent version of pip installed. To upgrade the pip module, type:<sup>7</sup>  \n```\n$ python3 -m pip install --user -U pip\nCollecting pip\n[...]\nSuccessfully installed pip-19.0.2\n```",
      "metadata": {
        "header": "**Get the Data**",
        "subheader": "**Create the Workspace**",
        "page": "3-4",
        "chunk_id": "chk_6ba8ca4d-77ce-4f64-8586-697952543a7b",
        "chunk_size": 280,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Creating an Isolated Environment**  \nIf you would like to work in an isolated environment (which is strongly recom‐ mended so you can work on different projects without having conflicting library ver‐ sions), install virtualenv<sup>8</sup> by running the following pip command (again, if you want virtualenv to be installed for all users on your machine, remove --user and run this command with administrator rights):  \n```\n$ python3 -m pip install --user -U virtualenv\nCollecting virtualenv\n[...]\nSuccessfully installed virtualenv\n```  \nNow you can create an isolated Python environment by typing:  \n```\n$ cd $ML_PATH\n$ virtualenv env\nUsing base prefix '[...]'\nNew python executable in [...]/ml/env/bin/python3.6\nAlso creating executable in [...]/ml/env/bin/python\nInstalling setuptools, pip, wheel...done.\n```  \n<sup>6</sup> We will show the installation steps using pip in a bash shell on a Linux or MacOS system. You may need to adapt these commands to your own system. On Windows, we recommend installing Anaconda instead.  \n<sup>7</sup> If you want to upgrade pip for all users on your machine rather than just your own user, you should remove the --user option and make sure you have administrator rights (e.g., by adding sudo before the whole com‐ mand on Linux or MacOSX).  \n<sup>8</sup> Alternative tools include venv (very similar to virtualenv and included in the standard library), virtualenv‐ wrapper (provides extra functionalities on top of virtualenv), pyenv (allows easy switching between Python versions), and pipenv (a great packaging tool by the same author as the popular requests library, built on top of pip, virtualenv and more).  \n{5}------------------------------------------------  \nNow every time you want to activate this environment, just open a terminal and type:  \n```\n$ cd $ML_PATH\n$ source env/bin/activate # on Linux or MacOSX\n$ .\\env\\Scripts\\activate # on Windows\n```  \nTo deactivate this environment, just type deactivate. While the environment is active, any package you install using pip will be installed in this isolated environment, and Python will only have access to these packages (if you also want access to the sys‐ tem's packages, you should create the environment using virtualenv's --system-sitepackages option). Check out virtualenv's documentation for more information.  \nNow you can install all the required modules and their dependencies using this sim‐ ple pip command (if you are not using a virtualenv, you will need the --user option or administrator rights):  \n```\n$ python3 -m pip install -U jupyter matplotlib numpy pandas scipy scikit-learn\nCollecting jupyter\nDownloading jupyter-1.0.0-py2.py3-none-any.whl\nCollecting matplotlib\n[...]\n```  \nTo check your installation, try to import every module like this:  \n```\n$ python3 -c \"import jupyter, matplotlib, numpy, pandas, scipy, sklearn\"\n```  \nThere should be no output and no error. Now you can fire up Jupyter by typing:  \n```\n$ jupyter notebook\n[I 15:24 NotebookApp] Serving notebooks from local directory: [...]/ml\n[I 15:24 NotebookApp] 0 active kernels\n[I 15:24 NotebookApp] The Jupyter Notebook is running at: http://localhost:8888/\n[I 15:24 NotebookApp] Use Control-C to stop this server and shut down all\nkernels (twice to skip confirmation).\n```  \nA Jupyter server is now running in your terminal, listening to port 8888. You can visit this server by opening your web browser to *http://localhost:8888/* (this usually hap‐ pens automatically when the server starts). You should see your empty workspace directory (containing only the *env* directory if you followed the preceding virtualenv instructions).  \nNow create a new Python notebook by clicking on the New button and selecting the appropriate Python version<sup>9</sup> (see [Figure 2-3\\)](#page-6-0).  \nThis does three things: first, it creates a new notebook file called *Untitled.ipynb* in your workspace; second, it starts a Jupyter Python kernel to run this notebook; and  \n<sup>9</sup> Note that Jupyter can handle multiple versions of Python, and even many other languages such as R or Octave.  \n{6}------------------------------------------------  \n<span id=\"page-6-0\"></span>third, it opens this notebook in a new tab. You should start by renaming this note‐ book to \"Housing\" (this will automatically rename the file to *Housing.ipynb*) by click‐ ing Untitled and typing the new name.  \n![](_page_6_Picture_1.jpeg)  \n*Figure 2-3. Your workspace in Jupyter*  \nA notebook contains a list of cells. Each cell can contain executable code or formatted text. Right now the notebook contains only one empty code cell, labeled \"In [1]:\". Try typing **print(\"Hello world!\")** in the cell, and click on the play button (see Figure 2-4) or press Shift-Enter. This sends the current cell to this notebook's Python kernel, which runs it and returns the output. The result is displayed below the cell, and since we reached the end of the notebook, a new cell is automatically created. Go through the User Interface Tour from Jupyter's Help menu to learn the basics.  \n![](_page_6_Picture_4.jpeg)  \n*Figure 2-4. Hello world Python notebook*  \n{7}------------------------------------------------",
      "metadata": {
        "header": "**Get the Data**",
        "subheader": "**Creating an Isolated Environment**",
        "page": "4-7",
        "chunk_id": "chk_4ef2750e-eb55-4f4d-a72b-58e0a2b29dca",
        "chunk_size": 763,
        "chunk_img_path": "_page_6_Picture_1.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_6_Picture_1.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### <span id=\"page-7-0\"></span>**Download the Data**  \nIn typical environments your data would be available in a relational database (or some other common datastore) and spread across multiple tables/documents/files. To access it, you would first need to get your credentials and access authorizations,<sup>10</sup> and familiarize yourself with the data schema. In this project, however, things are much simpler: you will just download a single compressed file, *housing.tgz*, which contains a comma-separated value (CSV) file called *housing.csv* with all the data.  \nYou could use your web browser to download it, and run tar xzf housing.tgz to decompress the file and extract the CSV file, but it is preferable to create a small func‐ tion to do that. It is useful in particular if data changes regularly, as it allows you to write a small script that you can run whenever you need to fetch the latest data (or you can set up a scheduled job to do that automatically at regular intervals). Auto‐ mating the process of fetching the data is also useful if you need to install the dataset on multiple machines.  \nHere is the function to fetch the data:<sup>11</sup>  \n```\nimport os\nimport tarfile\nfrom six.moves import urllib\nDOWNLOAD_ROOT = \"https://raw.githubusercontent.com/ageron/handson-ml2/master/\"\nHOUSING_PATH = os.path.join(\"datasets\", \"housing\")\nHOUSING_URL = DOWNLOAD_ROOT + \"datasets/housing/housing.tgz\"\ndef fetch_housing_data(housing_url=HOUSING_URL, housing_path=HOUSING_PATH):\nif not os.path.isdir(housing_path):\nos.makedirs(housing_path)\ntgz_path = os.path.join(housing_path, \"housing.tgz\")\nurllib.request.urlretrieve(housing_url, tgz_path)\nhousing_tgz = tarfile.open(tgz_path)\nhousing_tgz.extractall(path=housing_path)\nhousing_tgz.close()\n```  \nNow when you call fetch\\_housing\\_data(), it creates a *datasets/housing* directory in your workspace, downloads the *housing.tgz* file, and extracts the *housing.csv* from it in this directory.  \nNow let's load the data using Pandas. Once again you should write a small function to load the data:  \n<sup>10</sup> You might also need to check legal constraints, such as private fields that should never be copied to unsafe datastores.  \n<sup>11</sup> In a real project you would save this code in a Python file, but for now you can just write it in your Jupyter notebook.  \n{8}------------------------------------------------  \n```\nimport pandas as pd\ndef load_housing_data(housing_path=HOUSING_PATH):\ncsv_path = os.path.join(housing_path, \"housing.csv\")\nreturn pd.read_csv(csv_path)\n```  \nThis function returns a Pandas DataFrame object containing all the data.",
      "metadata": {
        "header": "**Get the Data**",
        "subheader": "<span id=\"page-7-0\"></span>**Download the Data**",
        "page": "7-8",
        "chunk_id": "chk_86c5196d-d3fe-45c9-b960-09bcfbb0554e",
        "chunk_size": 346,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Take a Quick Look at the Data Structure**  \nLet's take a look at the top five rows using the DataFrame's head() method (see Figure 2-5).  \n| In [5]: |   | ousing = 1<br>ousing.hea |          | using_data()       |             |                |           |\n|---------|---|--------------------------|----------|--------------------|-------------|----------------|-----------|\n| Out[5]: | Г | longitude                | latitude | housing_median_age | total_rooms | total_bedrooms | populatio |\n|         | 0 | -122.23                  | 37.88    | 41.0               | 880.0       | 129.0          | 322.0     |\n|         | 1 | -122.22                  | 37.86    | 21.0               | 7099.0      | 1106.0         | 2401.0    |\n|         | 2 | -122.24                  | 37.85    | 52.0               | 1467.0      | 190.0          | 496.0     |\n|         | 3 | -122.25                  | 37.85    | 52.0               | 1274.0      | 235.0          | 558.0     |\n|         | 4 | -122.25                  | 37.85    | 52.0               | 1627.0      | 280.0          | 565.0     |  \n*Figure 2-5. Top five rows in the dataset*  \nEach row represents one district. There are 10 attributes (you can see the first 6 in the screenshot): longitude, latitude, housing\\_median\\_age, total\\_rooms, total\\_bed rooms, population, households, median\\_income, median\\_house\\_value, and ocean\\_proximity.  \nThe info() method is useful to get a quick description of the data, in particular the total number of rows, and each attribute's type and number of non-null values (see [Figure 2-6](#page-9-0)).  \n{9}------------------------------------------------  \n*Figure 2-6. Housing info*  \nThere are 20,640 instances in the dataset, which means that it is fairly small by Machine Learning standards, but it's perfect to get started. Notice that the total\\_bed rooms attribute has only 20,433 non-null values, meaning that 207 districts are miss‐ ing this feature. We will need to take care of this later.  \nAll attributes are numerical, except the ocean\\_proximity field. Its type is object, so it could hold any kind of Python object, but since you loaded this data from a CSV file you know that it must be a text attribute. When you looked at the top five rows, you probably noticed that the values in the ocean\\_proximity column were repetitive, which means that it is probably a categorical attribute. You can find out what cate‐ gories exist and how many districts belong to each category by using the value\\_counts() method:  \n```\n>>> housing[\"ocean_proximity\"].value_counts()\n<1H OCEAN 9136\nINLAND 6551\nNEAR OCEAN 2658\nNEAR BAY 2290\nISLAND 5\nName: ocean_proximity, dtype: int64\n```  \nLet's look at the other fields. The describe() method shows a summary of the numerical attributes ([Figure 2-7](#page-10-0)).  \n{10}------------------------------------------------  \n<span id=\"page-10-0\"></span>  \n|       | longitude    | latitude     | housing_median_age | total_rooms  | total_bedro |\n|-------|--------------|--------------|--------------------|--------------|-------------|\n| count | 20640.000000 | 20640.000000 | 20640.000000       | 20640.000000 | 20433.0000  |\n| mean  | -119.569704  | 35.631861    | 28.639486          | 2635.763081  | 537.870553  |\n| std   | 2.003532     | 2.135952     | 12.585558          | 2181.615252  | 421.385070  |\n| min   | -124.350000  | 32.540000    | 1.000000           | 2.000000     | 1.000000    |\n| 25%   | -121.800000  | 33.930000    | 18.000000          | 1447.750000  | 296.000000  |\n| 50%   | -118.490000  | 34.260000    | 29.000000          | 2127.000000  | 435.000000  |\n| 75%   | -118.010000  | 37.710000    | 37.000000          | 3148.000000  | 647.000000  |\n| max   | -114.310000  | 41.950000    | 52.000000          | 39320.000000 | 6445.00000  |  \n*Figure 2-7. Summary of each numerical attribute*  \nThe count, mean, min, and max rows are self-explanatory. Note that the null values are ignored (so, for example, count of total\\_bedrooms is 20,433, not 20,640). The std row shows the *standard deviation*, which measures how dispersed the values are.<sup>12</sup> The 25%, 50%, and 75% rows show the corresponding *percentiles*: a percentile indi‐ cates the value below which a given percentage of observations in a group of observa‐ tions falls. For example, 25% of the districts have a housing\\_median\\_age lower than 18, while 50% are lower than 29 and 75% are lower than 37. These are often called the 25th percentile (or 1st *quartile*), the median, and the 75th percentile (or 3rd quartile).  \nAnother quick way to get a feel of the type of data you are dealing with is to plot a histogram for each numerical attribute. A histogram shows the number of instances (on the vertical axis) that have a given value range (on the horizontal axis). You can either plot this one attribute at a time, or you can call the hist() method on the whole dataset, and it will plot a histogram for each numerical attribute (see [Figure 2-8](#page-11-0)). For example, you can see that slightly over 800 districts have a median\\_house\\_value equal to about \\$100,000.  \n```\n%matplotlib inline # only in a Jupyter notebook\nimport matplotlib.pyplot as plt\nhousing.hist(bins=50, figsize=(20,15))\nplt.show()\n```  \n<sup>12</sup> The standard deviation is generally denoted σ (the Greek letter sigma), and it is the square root of the *var‐ iance*, which is the average of the squared deviation from the mean. When a feature has a bell-shaped *normal distribution* (also called a *Gaussian distribution*), which is very common, the \"68-95-99.7\" rule applies: about 68% of the values fall within 1σ of the mean, 95% within 2σ, and 99.7% within 3σ.  \n{11}------------------------------------------------  \n<span id=\"page-11-0\"></span>![](_page_11_Picture_0.jpeg)  \nThe hist() method relies on Matplotlib, which in turn relies on a user-specified graphical backend to draw on your screen. So before you can plot anything, you need to specify which backend Matplot‐ lib should use. The simplest option is to use Jupyter's magic com‐ mand %matplotlib inline. This tells Jupyter to set up Matplotlib so it uses Jupyter's own backend. Plots are then rendered within the notebook itself. Note that calling show() is optional in a Jupyter notebook, as Jupyter will automatically display plots when a cell is executed.  \n![](_page_11_Figure_2.jpeg)  \n*Figure 2-8. A histogram for each numerical attribute*",
      "metadata": {
        "header": "**Get the Data**",
        "subheader": "**Take a Quick Look at the Data Structure**",
        "page": "8-11",
        "chunk_id": "chk_f209336a-90d3-47d2-90f6-1b9e7ddf36e2",
        "chunk_size": 924,
        "chunk_img_path": "_page_11_Picture_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_11_Picture_0.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### Notice a few things in these histograms:  \n1. First, the median income attribute does not look like it is expressed in US dollars (USD). After checking with the team that collected the data, you are told that the data has been scaled and capped at 15 (actually 15.0001) for higher median incomes, and at 0.5 (actually 0.4999) for lower median incomes. The numbers represent roughly tens of thousands of dollars (e.g., 3 actually means about \\$30,000). Working with preprocessed attributes is common in Machine Learning,  \n{12}------------------------------------------------  \n- and it is not necessarily a problem, but you should try to understand how the data was computed.\n- 2. The housing median age and the median house value were also capped. The lat‐ ter may be a serious problem since it is your target attribute (your labels). Your Machine Learning algorithms may learn that prices never go beyond that limit. You need to check with your client team (the team that will use your system's out‐ put) to see if this is a problem or not. If they tell you that they need precise pre‐ dictions even beyond \\$500,000, then you have mainly two options:\n- a. Collect proper labels for the districts whose labels were capped.\n- b. Remove those districts from the training set (and also from the test set, since your system should not be evaluated poorly if it predicts values beyond \\$500,000).\n- 3. These attributes have very different scales. We will discuss this later in this chap‐ ter when we explore feature scaling.\n- 4. Finally, many histograms are *tail heavy*: they extend much farther to the right of the median than to the left. This may make it a bit harder for some Machine Learning algorithms to detect patterns. We will try transforming these attributes later on to have more bell-shaped distributions.  \nHopefully you now have a better understanding of the kind of data you are dealing with.  \n![](_page_12_Picture_7.jpeg)  \nWait! Before you look at the data any further, you need to create a test set, put it aside, and never look at it.",
      "metadata": {
        "header": "**Get the Data**",
        "subheader": "Notice a few things in these histograms:",
        "page": "11-12",
        "chunk_id": "chk_93d2fd8f-f609-40e5-9648-5b97066f5665",
        "chunk_size": 348,
        "chunk_img_path": "_page_12_Picture_7.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_12_Picture_7.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Create a Test Set**  \nIt may sound strange to voluntarily set aside part of the data at this stage. After all, you have only taken a quick glance at the data, and surely you should learn a whole lot more about it before you decide what algorithms to use, right? This is true, but your brain is an amazing pattern detection system, which means that it is highly prone to overfitting: if you look at the test set, you may stumble upon some seemingly interesting pattern in the test data that leads you to select a particular kind of Machine Learning model. When you estimate the generalization error using the test set, your estimate will be too optimistic and you will launch a system that will not perform as well as expected. This is called *data snooping* bias.  \nCreating a test set is theoretically quite simple: just pick some instances randomly, typically 20% of the dataset (or less if your dataset is very large), and set them aside:  \n{13}------------------------------------------------  \n```\nimport numpy as np\ndef split_train_test(data, test_ratio):\nshuffled_indices = np.random.permutation(len(data))\ntest_set_size = int(len(data) * test_ratio)\ntest_indices = shuffled_indices[:test_set_size]\ntrain_indices = shuffled_indices[test_set_size:]\nreturn data.iloc[train_indices], data.iloc[test_indices]\n```  \nYou can then use this function like this:<sup>13</sup>  \n```\n>>> train_set, test_set = split_train_test(housing, 0.2)\n>>> len(train_set)\n16512\n>>> len(test_set)\n4128\n```  \nWell, this works, but it is not perfect: if you run the program again, it will generate a different test set! Over time, you (or your Machine Learning algorithms) will get to see the whole dataset, which is what you want to avoid.  \nOne solution is to save the test set on the first run and then load it in subsequent runs. Another option is to set the random number generator's seed (e.g., np.ran dom.seed(42)) <sup>14</sup> before calling np.random.permutation(), so that it always generates the same shuffled indices.  \nBut both these solutions will break next time you fetch an updated dataset. A com‐ mon solution is to use each instance's identifier to decide whether or not it should go in the test set (assuming instances have a unique and immutable identifier). For example, you could compute a hash of each instance's identifier and put that instance in the test set if the hash is lower or equal to 20% of the maximum hash value. This ensures that the test set will remain consistent across multiple runs, even if you refresh the dataset. The new test set will contain 20% of the new instances, but it will not contain any instance that was previously in the training set. Here is a possible implementation:  \n```\nfrom zlib import crc32\ndef test_set_check(identifier, test_ratio):\nreturn crc32(np.int64(identifier)) & 0xffffffff < test_ratio * 2**32\ndef split_train_test_by_id(data, test_ratio, id_column):\nids = data[id_column]\n```  \n<sup>13</sup> In this book, when a code example contains a mix of code and outputs, as is the case here, it is formatted like in the Python interpreter, for better readability: the code lines are prefixed with >>> (or ... for indented blocks), and the outputs have no prefix.  \n<sup>14</sup> You will often see people set the random seed to 42. This number has no special property, other than to be The Answer to the Ultimate Question of Life, the Universe, and Everything.  \n{14}------------------------------------------------  \n```\nin_test_set = ids.apply(lambda id_: test_set_check(id_, test_ratio))\nreturn data.loc[~in_test_set], data.loc[in_test_set]\n```  \nUnfortunately, the housing dataset does not have an identifier column. The simplest solution is to use the row index as the ID:  \n```\nhousing_with_id = housing.reset_index() # adds an `index` column\ntrain_set, test_set = split_train_test_by_id(housing_with_id, 0.2, \"index\")\n```  \nIf you use the row index as a unique identifier, you need to make sure that new data gets appended to the end of the dataset, and no row ever gets deleted. If this is not possible, then you can try to use the most stable features to build a unique identifier. For example, a district's latitude and longitude are guaranteed to be stable for a few million years, so you could combine them into an ID like so:<sup>15</sup>  \n```\nhousing_with_id[\"id\"] = housing[\"longitude\"] * 1000 + housing[\"latitude\"]\ntrain_set, test_set = split_train_test_by_id(housing_with_id, 0.2, \"id\")\n```  \nScikit-Learn provides a few functions to split datasets into multiple subsets in various ways. The simplest function is train\\_test\\_split, which does pretty much the same thing as the function split\\_train\\_test defined earlier, with a couple of additional features. First there is a random\\_state parameter that allows you to set the random generator seed as explained previously, and second you can pass it multiple datasets with an identical number of rows, and it will split them on the same indices (this is very useful, for example, if you have a separate DataFrame for labels):  \n```\nfrom sklearn.model_selection import train_test_split\ntrain_set, test_set = train_test_split(housing, test_size=0.2, random_state=42)\n```  \nSo far we have considered purely random sampling methods. This is generally fine if your dataset is large enough (especially relative to the number of attributes), but if it is not, you run the risk of introducing a significant sampling bias. When a survey company decides to call 1,000 people to ask them a few questions, they don't just pick 1,000 people randomly in a phone book. They try to ensure that these 1,000 people are representative of the whole population. For example, the US population is com‐ posed of 51.3% female and 48.7% male, so a well-conducted survey in the US would try to maintain this ratio in the sample: 513 female and 487 male. This is called *strati‐ fied sampling*: the population is divided into homogeneous subgroups called *strata*, and the right number of instances is sampled from each stratum to guarantee that the test set is representative of the overall population. If they used purely random sam‐ pling, there would be about 12% chance of sampling a skewed test set with either less than 49% female or more than 54% female. Either way, the survey results would be significantly biased.  \n<sup>15</sup> The location information is actually quite coarse, and as a result many districts will have the exact same ID, so they will end up in the same set (test or train). This introduces some unfortunate sampling bias.  \n{15}------------------------------------------------  \nSuppose you chatted with experts who told you that the median income is a very important attribute to predict median housing prices. You may want to ensure that the test set is representative of the various categories of incomes in the whole dataset. Since the median income is a continuous numerical attribute, you first need to create an income category attribute. Let's look at the median income histogram more closely (back in [Figure 2-8](#page-11-0)): most median income values are clustered around 1.5 to 6 (i.e., \\$15,000–\\$60,000), but some median incomes go far beyond 6. It is important to have a sufficient number of instances in your dataset for each stratum, or else the estimate of the stratum's importance may be biased. This means that you should not have too many strata, and each stratum should be large enough. The following code uses the pd.cut() function to create an income category attribute with 5 categories (labeled from 1 to 5): category 1 ranges from 0 to 1.5 (i.e., less than \\$15,000), category 2 from 1.5 to 3, and so on:  \n```\nhousing[\"income_cat\"] = pd.cut(housing[\"median_income\"],\nbins=[0., 1.5, 3.0, 4.5, 6., np.inf],\nlabels=[1, 2, 3, 4, 5])\n```  \nThese income categories are represented in Figure 2-9:  \nhousing[\"income\\_cat\"].hist()  \n![](_page_15_Figure_4.jpeg)  \n*Figure 2-9. Histogram of income categories*  \nNow you are ready to do stratified sampling based on the income category. For this you can use Scikit-Learn's StratifiedShuffleSplit class:  \n```\nfrom sklearn.model_selection import StratifiedShuffleSplit\nsplit = StratifiedShuffleSplit(n_splits=1, test_size=0.2, random_state=42)\nfor train_index, test_index in split.split(housing, housing[\"income_cat\"]):\nstrat_train_set = housing.loc[train_index]\nstrat_test_set = housing.loc[test_index]\n```  \n{16}------------------------------------------------  \nLet's see if this worked as expected. You can start by looking at the income category proportions in the test set:  \n```\n>>> strat_test_set[\"income_cat\"].value_counts() / len(strat_test_set)\n3 0.350533\n2 0.318798\n4 0.176357\n5 0.114583\n1 0.039729\nName: income_cat, dtype: float64\n```  \nWith similar code you can measure the income category proportions in the full data‐ set. Figure 2-10 compares the income category proportions in the overall dataset, in the test set generated with stratified sampling, and in a test set generated using purely random sampling. As you can see, the test set generated using stratified sampling has income category proportions almost identical to those in the full dataset, whereas the test set generated using purely random sampling is quite skewed.  \n|     | Overall  | Random   | Stratified | Rand. %error | Strat. %error |\n|-----|----------|----------|------------|--------------|---------------|\n| 1.0 | 0.039826 | 0.040213 | 0.039738   | 0.973236     | -0.219137     |\n| 2.0 | 0.318847 | 0.324370 | 0.318876   | 1.732260     | 0.009032      |\n| 3.0 | 0.350581 | 0.358527 | 0.350618   | 2.266446     | 0.010408      |\n| 4.0 | 0.176308 | 0.167393 | 0.176399   | -5.056334    | 0.051717      |\n| 5.0 | 0.114438 | 0.109496 | 0.114369   | -4.318374    | -0.060464     |  \n*Figure 2-10. Sampling bias comparison of stratified versus purely random sampling*  \nNow you should remove the income\\_cat attribute so the data is back to its original state:  \n```\nfor set_ in (strat_train_set, strat_test_set):\nset_.drop(\"income_cat\", axis=1, inplace=True)\n```  \nWe spent quite a bit of time on test set generation for a good reason: this is an often neglected but critical part of a Machine Learning project. Moreover, many of these ideas will be useful later when we discuss cross-validation. Now it's time to move on to the next stage: exploring the data.",
      "metadata": {
        "header": "**Create a Test Set**",
        "subheader": null,
        "page": "12-16",
        "chunk_id": "chk_7d5c800f-da33-4a5a-859f-5f39c3762ea2",
        "chunk_size": 1565,
        "chunk_img_path": "_page_15_Figure_4.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_15_Figure_4.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Discover and Visualize the Data to Gain Insights**  \nSo far you have only taken a quick glance at the data to get a general understanding of the kind of data you are manipulating. Now the goal is to go a little bit more in depth.  \nFirst, make sure you have put the test set aside and you are only exploring the train‐ ing set. Also, if the training set is very large, you may want to sample an exploration  \n{17}------------------------------------------------  \nset, to make manipulations easy and fast. In our case, the set is quite small so you can just work directly on the full set. Let's create a copy so you can play with it without harming the training set:  \n```\nhousing = strat_train_set.copy()\n```",
      "metadata": {
        "header": "**Discover and Visualize the Data to Gain Insights**",
        "subheader": null,
        "page": "16-17",
        "chunk_id": "chk_ece49073-cd91-44da-9113-54f9cbd2794d",
        "chunk_size": 126,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Visualizing Geographical Data**  \nSince there is geographical information (latitude and longitude), it is a good idea to create a scatterplot of all districts to visualize the data (Figure 2-11):  \nhousing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\")  \n![](_page_17_Figure_5.jpeg)  \n*Figure 2-11. A geographical scatterplot of the data*  \nThis looks like California all right, but other than that it is hard to see any particular pattern. Setting the alpha option to 0.1 makes it much easier to visualize the places where there is a high density of data points [\\(Figure 2-12\\)](#page-18-0):  \n```\nhousing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\", alpha=0.1)\n```  \n{18}------------------------------------------------  \n<span id=\"page-18-0\"></span>![](_page_18_Figure_0.jpeg)  \n*Figure 2-12. A better visualization highlighting high-density areas*  \nNow that's much better: you can clearly see the high-density areas, namely the Bay Area and around Los Angeles and San Diego, plus a long line of fairly high density in the Central Valley, in particular around Sacramento and Fresno.  \nMore generally, our brains are very good at spotting patterns on pictures, but you may need to play around with visualization parameters to make the patterns stand out.  \nNow let's look at the housing prices [\\(Figure 2-13\\)](#page-19-0). The radius of each circle represents the district's population (option s), and the color represents the price (option c). We will use a predefined color map (option cmap) called jet, which ranges from blue (low values) to red (high prices):<sup>16</sup>  \n```\nhousing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\", alpha=0.4,\ns=housing[\"population\"]/100, label=\"population\", figsize=(10,7),\nc=\"median_house_value\", cmap=plt.get_cmap(\"jet\"), colorbar=True,\n)\nplt.legend()\n```  \n<sup>16</sup> If you are reading this in grayscale, grab a red pen and scribble over most of the coastline from the Bay Area down to San Diego (as you might expect). You can add a patch of yellow around Sacramento as well.  \n{19}------------------------------------------------  \n<span id=\"page-19-0\"></span>![](_page_19_Figure_0.jpeg)  \n*Figure 2-13. California housing prices*  \n{20}------------------------------------------------  \nThis image tells you that the housing prices are very much related to the location (e.g., close to the ocean) and to the population density, as you probably knew already. It will probably be useful to use a clustering algorithm to detect the main clusters, and add new features that measure the proximity to the cluster centers. The ocean prox‐ imity attribute may be useful as well, although in Northern California the housing prices in coastal districts are not too high, so it is not a simple rule.",
      "metadata": {
        "header": "**Discover and Visualize the Data to Gain Insights**",
        "subheader": "**Visualizing Geographical Data**",
        "page": "17-20",
        "chunk_id": "chk_e6388361-e6ab-48c1-9d66-bfc1672fef97",
        "chunk_size": 372,
        "chunk_img_path": "_page_17_Figure_5.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_17_Figure_5.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Looking for Correlations**  \nSince the dataset is not too large, you can easily compute the *standard correlation coecient* (also called *Pearson's r*) between every pair of attributes using the corr() method:  \n```\ncorr_matrix = housing.corr()\n```  \nNow let's look at how much each attribute correlates with the median house value:  \n```\n>>> corr_matrix[\"median_house_value\"].sort_values(ascending=False)\nmedian_house_value 1.000000\nmedian_income 0.687170\ntotal_rooms 0.135231\nhousing_median_age 0.114220\nhouseholds 0.064702\ntotal_bedrooms 0.047865\npopulation -0.026699\nlongitude -0.047279\nlatitude -0.142826\nName: median_house_value, dtype: float64\n```  \nThe correlation coefficient ranges from –1 to 1. When it is close to 1, it means that there is a strong positive correlation; for example, the median house value tends to go up when the median income goes up. When the coefficient is close to –1, it means that there is a strong negative correlation; you can see a small negative correlation between the latitude and the median house value (i.e., prices have a slight tendency to go down when you go north). Finally, coefficients close to zero mean that there is no linear correlation. [Figure 2-14](#page-21-0) shows various plots along with the correlation coeffi‐ cient between their horizontal and vertical axes.  \n{21}------------------------------------------------  \n<span id=\"page-21-0\"></span>![](_page_21_Figure_0.jpeg)  \n*Figure 2-14. Standard correlation coecient of various datasets (source: Wikipedia; public domain image)*  \n![](_page_21_Picture_2.jpeg)  \nThe correlation coefficient only measures linear correlations (\"if *x* goes up, then *y* generally goes up/down\"). It may completely miss out on nonlinear relationships (e.g., \"if *x* is close to zero then *y* gen‐ erally goes up\"). Note how all the plots of the bottom row have a correlation coefficient equal to zero despite the fact that their axes are clearly not independent: these are examples of nonlinear rela‐ tionships. Also, the second row shows examples where the correla‐ tion coefficient is equal to 1 or –1; notice that this has nothing to do with the slope. For example, your height in inches has a correla‐ tion coefficient of 1 with your height in feet or in nanometers.  \nAnother way to check for correlation between attributes is to use Pandas' scatter\\_matrix function, which plots every numerical attribute against every other numerical attribute. Since there are now 11 numerical attributes, you would get 11<sup>2</sup> = 121 plots, which would not fit on a page, so let's just focus on a few promising attributes that seem most correlated with the median housing value [\\(Figure 2-15\\)](#page-22-0):  \n```\nfrom pandas.plotting import scatter_matrix\nattributes = [\"median_house_value\", \"median_income\", \"total_rooms\",\n\"housing_median_age\"]\nscatter_matrix(housing[attributes], figsize=(12, 8))\n```  \n{22}------------------------------------------------  \n<span id=\"page-22-0\"></span>![](_page_22_Figure_0.jpeg)  \n*Figure 2-15. Scatter matrix*  \nThe main diagonal (top left to bottom right) would be full of straight lines if Pandas plotted each variable against itself, which would not be very useful. So instead Pandas displays a histogram of each attribute (other options are available; see Pandas' docu‐ mentation for more details).  \nThe most promising attribute to predict the median house value is the median income, so let's zoom in on their correlation scatterplot [\\(Figure 2-16\\)](#page-23-0):  \n```\nhousing.plot(kind=\"scatter\", x=\"median_income\", y=\"median_house_value\",\nalpha=0.1)\n```  \nThis plot reveals a few things. First, the correlation is indeed very strong; you can clearly see the upward trend and the points are not too dispersed. Second, the price cap that we noticed earlier is clearly visible as a horizontal line at \\$500,000. But this plot reveals other less obvious straight lines: a horizontal line around \\$450,000, another around \\$350,000, perhaps one around \\$280,000, and a few more below that. You may want to try removing the corresponding districts to prevent your algorithms from learning to reproduce these data quirks.  \n{23}------------------------------------------------  \n<span id=\"page-23-0\"></span>![](_page_23_Figure_0.jpeg)  \n*Figure 2-16. Median income versus median house value*",
      "metadata": {
        "header": "**Discover and Visualize the Data to Gain Insights**",
        "subheader": "**Looking for Correlations**",
        "page": "20-23",
        "chunk_id": "chk_a1922945-82c3-4f2b-9a3c-4f4eff4f6699",
        "chunk_size": 590,
        "chunk_img_path": "_page_21_Figure_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_21_Figure_0.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Experimenting with Attribute Combinations**  \nHopefully the previous sections gave you an idea of a few ways you can explore the data and gain insights. You identified a few data quirks that you may want to clean up before feeding the data to a Machine Learning algorithm, and you found interesting correlations between attributes, in particular with the target attribute. You also noticed that some attributes have a tail-heavy distribution, so you may want to trans‐ form them (e.g., by computing their logarithm). Of course, your mileage will vary considerably with each project, but the general ideas are similar.  \nOne last thing you may want to do before actually preparing the data for Machine Learning algorithms is to try out various attribute combinations. For example, the total number of rooms in a district is not very useful if you don't know how many households there are. What you really want is the number of rooms per household. Similarly, the total number of bedrooms by itself is not very useful: you probably want to compare it to the number of rooms. And the population per household also seems like an interesting attribute combination to look at. Let's create these new attributes:  \n```\nhousing[\"rooms_per_household\"] = housing[\"total_rooms\"]/housing[\"households\"]\nhousing[\"bedrooms_per_room\"] = housing[\"total_bedrooms\"]/housing[\"total_rooms\"]\nhousing[\"population_per_household\"]=housing[\"population\"]/housing[\"households\"]\n```  \nAnd now let's look at the correlation matrix again:  \n```\n>>> corr_matrix = housing.corr()\n>>> corr_matrix[\"median_house_value\"].sort_values(ascending=False)\nmedian_house_value 1.000000\n```  \n{24}------------------------------------------------  \n```\nmedian_income 0.687160\nrooms_per_household 0.146285\ntotal_rooms 0.135097\nhousing_median_age 0.114110\nhouseholds 0.064506\ntotal_bedrooms 0.047689\npopulation_per_household -0.021985\npopulation -0.026920\nlongitude -0.047432\nlatitude -0.142724\nbedrooms_per_room -0.259984\nName: median_house_value, dtype: float64\n```  \nHey, not bad! The new bedrooms\\_per\\_room attribute is much more correlated with the median house value than the total number of rooms or bedrooms. Apparently houses with a lower bedroom/room ratio tend to be more expensive. The number of rooms per household is also more informative than the total number of rooms in a district—obviously the larger the houses, the more expensive they are.  \nThis round of exploration does not have to be absolutely thorough; the point is to start off on the right foot and quickly gain insights that will help you get a first rea‐ sonably good prototype. But this is an iterative process: once you get a prototype up and running, you can analyze its output to gain more insights and come back to this exploration step.",
      "metadata": {
        "header": "**Discover and Visualize the Data to Gain Insights**",
        "subheader": "**Experimenting with Attribute Combinations**",
        "page": "23-24",
        "chunk_id": "chk_ce798f3a-f235-412a-adc0-6ae0f675cb63",
        "chunk_size": 387,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Prepare the Data for Machine Learning Algorithms**  \nIt's time to prepare the data for your Machine Learning algorithms. Instead of just doing this manually, you should write functions to do that, for several good reasons:  \n- This will allow you to reproduce these transformations easily on any dataset (e.g., the next time you get a fresh dataset).\n- You will gradually build a library of transformation functions that you can reuse in future projects.\n- You can use these functions in your live system to transform the new data before feeding it to your algorithms.\n- This will make it possible for you to easily try various transformations and see which combination of transformations works best.  \nBut first let's revert to a clean training set (by copying strat\\_train\\_set once again), and let's separate the predictors and the labels since we don't necessarily want to apply the same transformations to the predictors and the target values (note that drop() creates a copy of the data and does not affect strat\\_train\\_set):  \n```\nhousing = strat_train_set.drop(\"median_house_value\", axis=1)\nhousing_labels = strat_train_set[\"median_house_value\"].copy()\n```  \n{25}------------------------------------------------",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": null,
        "page": "24-25",
        "chunk_id": "chk_e388d1dc-b990-425c-a186-62463a49abdc",
        "chunk_size": 180,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Data Cleaning**  \nMost Machine Learning algorithms cannot work with missing features, so let's create a few functions to take care of them. You noticed earlier that the total\\_bedrooms attribute has some missing values, so let's fix this. You have three options:  \n- Get rid of the corresponding districts.\n- Get rid of the whole attribute.\n- Set the values to some value (zero, the mean, the median, etc.).  \nYou can accomplish these easily using DataFrame's dropna(), drop(), and fillna() methods:  \n```\nhousing.dropna(subset=[\"total_bedrooms\"]) # option 1\nhousing.drop(\"total_bedrooms\", axis=1) # option 2\nmedian = housing[\"total_bedrooms\"].median() # option 3\nhousing[\"total_bedrooms\"].fillna(median, inplace=True)\n```  \nIf you choose option 3, you should compute the median value on the training set, and use it to fill the missing values in the training set, but also don't forget to save the median value that you have computed. You will need it later to replace missing values in the test set when you want to evaluate your system, and also once the system goes live to replace missing values in new data.  \nScikit-Learn provides a handy class to take care of missing values: SimpleImputer. Here is how to use it. First, you need to create a SimpleImputer instance, specifying that you want to replace each attribute's missing values with the median of that attribute:  \n```\nfrom sklearn.impute import SimpleImputer\nimputer = SimpleImputer(strategy=\"median\")\n```  \nSince the median can only be computed on numerical attributes, we need to create a copy of the data without the text attribute ocean\\_proximity:  \n```\nhousing_num = housing.drop(\"ocean_proximity\", axis=1)\n```  \nNow you can fit the imputer instance to the training data using the fit() method:  \n```\nimputer.fit(housing_num)\n```  \nThe imputer has simply computed the median of each attribute and stored the result in its statistics\\_ instance variable. Only the total\\_bedrooms attribute had missing values, but we cannot be sure that there won't be any missing values in new data after the system goes live, so it is safer to apply the imputer to all the numerical attributes:  \n```\n>>> imputer.statistics_\narray([ -118.51 , 34.26 , 29. , 2119.5 , 433. , 1164. , 408. , 3.5409])\n```  \n{26}------------------------------------------------  \n```\n>>> housing_num.median().values\narray([ -118.51 , 34.26 , 29. , 2119.5 , 433. , 1164. , 408. , 3.5409])\n```  \nNow you can use this \"trained\" imputer to transform the training set by replacing missing values by the learned medians:  \n```\nX = imputer.transform(housing_num)\n```  \nThe result is a plain NumPy array containing the transformed features. If you want to put it back into a Pandas DataFrame, it's simple:  \n```\nhousing_tr = pd.DataFrame(X, columns=housing_num.columns)\n```",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": "**Data Cleaning**",
        "page": "25-26",
        "chunk_id": "chk_ff578469-990c-4e62-83d8-aed520d35a77",
        "chunk_size": 428,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Scikit-Learn Design**  \nScikit-Learn's API is remarkably well designed. The [main design principles](https://homl.info/11) are:<sup>17</sup>  \n- **Consistency**. All objects share a consistent and simple interface:\n- *Estimators*. Any object that can estimate some parameters based on a dataset is called an *estimator* (e.g., an imputer is an estimator). The estimation itself is performed by the fit() method, and it takes only a dataset as a parameter (or two for supervised learning algorithms; the second dataset contains the labels). Any other parameter needed to guide the estimation process is con‐ sidered a hyperparameter (such as an imputer's strategy), and it must be set as an instance variable (generally via a constructor parameter).\n- *Transformers*. Some estimators (such as an imputer) can also transform a dataset; these are called *transformers*. Once again, the API is quite simple: the transformation is performed by the transform() method with the dataset to transform as a parameter. It returns the transformed dataset. This transforma‐ tion generally relies on the learned parameters, as is the case for an imputer. All transformers also have a convenience method called fit\\_transform() that is equivalent to calling fit() and then transform() (but sometimes fit\\_transform() is optimized and runs much faster).\n- *Predictors*. Finally, some estimators are capable of making predictions given a dataset; they are called *predictors*. For example, the LinearRegression model in the previous chapter was a predictor: it predicted life satisfaction given a country's GDP per capita. A predictor has a predict() method that takes a dataset of new instances and returns a dataset of corresponding predictions. It also has a score() method that measures the quality of the predictions given  \n<sup>17</sup> For more details on the design principles, see \"API design for machine learning software: experiences from the scikit-learn project,\" L. Buitinck, G. Louppe, M. Blondel, F. Pedregosa, A. Müller, et al. (2013).  \n{27}------------------------------------------------  \n- a test set (and the corresponding labels in the case of supervised learning algorithms).<sup>18</sup>\n- **Inspection**. All the estimator's hyperparameters are accessible directly via public instance variables (e.g., imputer.strategy), and all the estimator's learned parameters are also accessible via public instance variables with an underscore suffix (e.g., imputer.statistics\\_).\n- **Nonproliferation of classes**. Datasets are represented as NumPy arrays or SciPy sparse matrices, instead of homemade classes. Hyperparameters are just regular Python strings or numbers.\n- **Composition**. Existing building blocks are reused as much as possible. For example, it is easy to create a Pipeline estimator from an arbitrary sequence of transformers followed by a final estimator, as we will see.\n- **Sensible defaults**. Scikit-Learn provides reasonable default values for most parameters, making it easy to create a baseline working system quickly.",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": "**Scikit-Learn Design**",
        "page": "26-27",
        "chunk_id": "chk_11257714-de45-4224-abc0-398bbbb975eb",
        "chunk_size": 437,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Handling Text and Categorical Attributes**  \nEarlier we left out the categorical attribute ocean\\_proximity because it is a text attribute so we cannot compute its median:  \n```\n>>> housing_cat = housing[[\"ocean_proximity\"]]\n>>> housing_cat.head(10)\nocean_proximity\n17606 <1H OCEAN\n18632 <1H OCEAN\n14650 NEAR OCEAN\n3230 INLAND\n3555 <1H OCEAN\n19480 INLAND\n8879 <1H OCEAN\n13685 INLAND\n4937 <1H OCEAN\n4861 <1H OCEAN\n```  \nMost Machine Learning algorithms prefer to work with numbers anyway, so let's con‐ vert these categories from text to numbers. For this, we can use Scikit-Learn's Ordina lEncoder class<sup>19</sup>:  \n```\n>>> from sklearn.preprocessing import OrdinalEncoder\n>>> ordinal_encoder = OrdinalEncoder()\n```  \n<sup>18</sup> Some predictors also provide methods to measure the confidence of their predictions.  \n<sup>19</sup> This class is available since Scikit-Learn 0.20. If you use an earlier version, please consider upgrading, or use Pandas' Series.factorize() method.  \n{28}------------------------------------------------  \n```\n>>> housing_cat_encoded = ordinal_encoder.fit_transform(housing_cat)\n>>> housing_cat_encoded[:10]\narray([[0.],\n[0.],\n[4.],\n[1.],\n[0.],\n[1.],\n[0.],\n[1.],\n[0.],\n[0.]])\n```  \nYou can get the list of categories using the categories\\_ instance variable. It is a list containing a 1D array of categories for each categorical attribute (in this case, a list containing a single array since there is just one categorical attribute):  \n```\n>>> ordinal_encoder.categories_\n[array(['<1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN'],\ndtype=object)]\n```  \nOne issue with this representation is that ML algorithms will assume that two nearby values are more similar than two distant values. This may be fine in some cases (e.g., for ordered categories such as \"bad\", \"average\", \"good\", \"excellent\"), but it is obviously not the case for the ocean\\_proximity column (for example, categories 0 and 4 are clearly more similar than categories 0 and 1). To fix this issue, a common solution is to create one binary attribute per category: one attribute equal to 1 when the category is \"<1H OCEAN\" (and 0 otherwise), another attribute equal to 1 when the category is \"INLAND\" (and 0 otherwise), and so on. This is called *one-hot encoding*, because only one attribute will be equal to 1 (hot), while the others will be 0 (cold). The new attributes are sometimes called *dummy* attributes. Scikit-Learn provides a OneHotEn coder class to convert categorical values into one-hot vectors<sup>20</sup>:  \n```\n>>> from sklearn.preprocessing import OneHotEncoder\n>>> cat_encoder = OneHotEncoder()\n>>> housing_cat_1hot = cat_encoder.fit_transform(housing_cat)\n>>> housing_cat_1hot\n<16512x5 sparse matrix of type '<class 'numpy.float64'>'\nwith 16512 stored elements in Compressed Sparse Row format>\n```  \nNotice that the output is a SciPy *sparse matrix*, instead of a NumPy array. This is very useful when you have categorical attributes with thousands of categories. After onehot encoding we get a matrix with thousands of columns, and the matrix is full of zeros except for a single 1 per row. Using up tons of memory mostly to store zeros would be very wasteful, so instead a sparse matrix only stores the location of the non‐  \n<sup>20</sup> Before Scikit-Learn 0.20, it could only encode integer categorical values, but since 0.20 it can also handle other types of inputs, including text categorical inputs.  \n{29}------------------------------------------------  \nzero elements. You can use it mostly like a normal 2D array,<sup>21</sup> but if you really want to convert it to a (dense) NumPy array, just call the toarray() method:  \n```\n>>> housing_cat_1hot.toarray()\narray([[1., 0., 0., 0., 0.],\n[1., 0., 0., 0., 0.],\n[0., 0., 0., 0., 1.],\n...,\n[0., 1., 0., 0., 0.],\n[1., 0., 0., 0., 0.],\n[0., 0., 0., 1., 0.]])\n```  \nOnce again, you can get the list of categories using the encoder's categories\\_ instance variable:  \n```\n>>> cat_encoder.categories_\n[array(['<1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN'],\ndtype=object)]\n```  \n![](_page_29_Picture_4.jpeg)  \nIf a categorical attribute has a large number of possible categories (e.g., country code, profession, species, etc.), then one-hot encod‐ ing will result in a large number of input features. This may slow down training and degrade performance. If this happens, you may want to replace the categorical input with useful numerical features related to the categories: for example, you could replace the ocean\\_proximity feature with the distance to the ocean (similarly, a country code could be replaced with the country's population and GDP per capita). Alternatively, you could replace each category with a learnable low dimensional vector called an *embedding*. Each category's representation would be learned during training: this is an example of *representation learning* (see Chapter 13 and ??? for more details).",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": "**Handling Text and Categorical Attributes**",
        "page": "27-29",
        "chunk_id": "chk_15b767e4-3e0a-4761-847a-c4a67cf9f407",
        "chunk_size": 719,
        "chunk_img_path": "_page_29_Picture_4.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_29_Picture_4.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Custom Transformers**  \nAlthough Scikit-Learn provides many useful transformers, you will need to write your own for tasks such as custom cleanup operations or combining specific attributes. You will want your transformer to work seamlessly with Scikit-Learn func‐ tionalities (such as pipelines), and since Scikit-Learn relies on duck typing (not inher‐ itance), all you need is to create a class and implement three methods: fit() (returning self), transform(), and fit\\_transform(). You can get the last one for free by simply adding TransformerMixin as a base class. Also, if you add BaseEstima tor as a base class (and avoid \\*args and \\*\\*kargs in your constructor) you will get two extra methods (get\\_params() and set\\_params()) that will be useful for auto‐  \n<sup>21</sup> See SciPy's documentation for more details.  \n{30}------------------------------------------------  \nmatic hyperparameter tuning. For example, here is a small transformer class that adds the combined attributes we discussed earlier:  \n```\nfrom sklearn.base import BaseEstimator, TransformerMixin\nrooms_ix, bedrooms_ix, population_ix, households_ix = 3, 4, 5, 6\nclass CombinedAttributesAdder(BaseEstimator, TransformerMixin):\ndef __init__(self, add_bedrooms_per_room = True): # no *args or **kargs\nself.add_bedrooms_per_room = add_bedrooms_per_room\ndef fit(self, X, y=None):\nreturn self # nothing else to do\ndef transform(self, X, y=None):\nrooms_per_household = X[:, rooms_ix] / X[:, households_ix]\npopulation_per_household = X[:, population_ix] / X[:, households_ix]\nif self.add_bedrooms_per_room:\nbedrooms_per_room = X[:, bedrooms_ix] / X[:, rooms_ix]\nreturn np.c_[X, rooms_per_household, population_per_household,\nbedrooms_per_room]\nelse:\nreturn np.c_[X, rooms_per_household, population_per_household]\nattr_adder = CombinedAttributesAdder(add_bedrooms_per_room=False)\nhousing_extra_attribs = attr_adder.transform(housing.values)\n```  \nIn this example the transformer has one hyperparameter, add\\_bedrooms\\_per\\_room, set to True by default (it is often helpful to provide sensible defaults). This hyperpara‐ meter will allow you to easily find out whether adding this attribute helps the Machine Learning algorithms or not. More generally, you can add a hyperparameter to gate any data preparation step that you are not 100% sure about. The more you automate these data preparation steps, the more combinations you can automatically try out, making it much more likely that you will find a great combination (and sav‐ ing you a lot of time).",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": "**Custom Transformers**",
        "page": "29-30",
        "chunk_id": "chk_afd7995f-ede9-48ba-bc2c-afa195f1e3ab",
        "chunk_size": 331,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Feature Scaling**  \nOne of the most important transformations you need to apply to your data is *feature scaling*. With few exceptions, Machine Learning algorithms don't perform well when the input numerical attributes have very different scales. This is the case for the hous‐ ing data: the total number of rooms ranges from about 6 to 39,320, while the median incomes only range from 0 to 15. Note that scaling the target values is generally not required.  \nThere are two common ways to get all attributes to have the same scale: *min-max scaling* and *standardization*.  \nMin-max scaling (many people call this *normalization*) is quite simple: values are shifted and rescaled so that they end up ranging from 0 to 1. We do this by subtract‐ ing the min value and dividing by the max minus the min. Scikit-Learn provides a  \n{31}------------------------------------------------  \ntransformer called MinMaxScaler for this. It has a feature\\_range hyperparameter that lets you change the range if you don't want 0–1 for some reason.  \nStandardization is quite different: first it subtracts the mean value (so standardized values always have a zero mean), and then it divides by the standard deviation so that the resulting distribution has unit variance. Unlike min-max scaling, standardization does not bound values to a specific range, which may be a problem for some algo‐ rithms (e.g., neural networks often expect an input value ranging from 0 to 1). How‐ ever, standardization is much less affected by outliers. For example, suppose a district had a median income equal to 100 (by mistake). Min-max scaling would then crush all the other values from 0–15 down to 0–0.15, whereas standardization would not be much affected. Scikit-Learn provides a transformer called StandardScaler for stand‐ ardization.  \n![](_page_31_Picture_2.jpeg)  \nAs with all the transformations, it is important to fit the scalers to the training data only, not to the full dataset (including the test set). Only then can you use them to transform the training set and the test set (and new data).",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": "**Feature Scaling**",
        "page": "30-31",
        "chunk_id": "chk_a76cd77d-4f37-4030-b306-d69c4cdb82a7",
        "chunk_size": 331,
        "chunk_img_path": "_page_31_Picture_2.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_31_Picture_2.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Transformation Pipelines**  \nAs you can see, there are many data transformation steps that need to be executed in the right order. Fortunately, Scikit-Learn provides the Pipeline class to help with such sequences of transformations. Here is a small pipeline for the numerical attributes:  \n```\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import StandardScaler\nnum_pipeline = Pipeline([\n('imputer', SimpleImputer(strategy=\"median\")),\n('attribs_adder', CombinedAttributesAdder()),\n('std_scaler', StandardScaler()),\n])\nhousing_num_tr = num_pipeline.fit_transform(housing_num)\n```  \nThe Pipeline constructor takes a list of name/estimator pairs defining a sequence of steps. All but the last estimator must be transformers (i.e., they must have a fit\\_transform() method). The names can be anything you like (as long as they are unique and don't contain double underscores \"\\_\\_\"): they will come in handy later for hyperparameter tuning.  \nWhen you call the pipeline's fit() method, it calls fit\\_transform() sequentially on all transformers, passing the output of each call as the parameter to the next call, until it reaches the final estimator, for which it just calls the fit() method.  \n{32}------------------------------------------------  \nThe pipeline exposes the same methods as the final estimator. In this example, the last estimator is a StandardScaler, which is a transformer, so the pipeline has a trans form() method that applies all the transforms to the data in sequence (and of course also a fit\\_transform() method, which is the one we used).  \nSo far, we have handled the categorical columns and the numerical columns sepa‐ rately. It would be more convenient to have a single transformer able to handle all col‐ umns, applying the appropriate transformations to each column. In version 0.20, Scikit-Learn introduced the ColumnTransformer for this purpose, and the good news is that it works great with Pandas DataFrames. Let's use it to apply all the transforma‐ tions to the housing data:  \n```\nfrom sklearn.compose import ColumnTransformer\nnum_attribs = list(housing_num)\ncat_attribs = [\"ocean_proximity\"]\nfull_pipeline = ColumnTransformer([\n(\"num\", num_pipeline, num_attribs),\n(\"cat\", OneHotEncoder(), cat_attribs),\n])\nhousing_prepared = full_pipeline.fit_transform(housing)\n```  \nHere is how this works: first we import the ColumnTransformer class, next we get the list of numerical column names and the list of categorical column names, and we construct a ColumnTransformer. The constructor requires a list of tuples, where each tuple contains a name<sup>22</sup>, a transformer and a list of names (or indices) of columns that the transformer should be applied to. In this example, we specify that the numer‐ ical columns should be transformed using the num\\_pipeline that we defined earlier, and the categorical columns should be transformed using a OneHotEncoder. Finally, we apply this ColumnTransformer to the housing data: it applies each transformer to the appropriate columns and concatenates the outputs along the second axis (the transformers must return the same number of rows).  \nNote that the OneHotEncoder returns a sparse matrix, while the num\\_pipeline returns a dense matrix. When there is such a mix of sparse and dense matrices, the Colum nTransformer estimates the density of the final matrix (i.e., the ratio of non-zero cells), and it returns a sparse matrix if the density is lower than a given threshold (by default, sparse\\_threshold=0.3). In this example, it returns a dense matrix. And that's it! We have a preprocessing pipeline that takes the full housing data and applies the appropriate transformations to each column.  \n<sup>22</sup> Just like for pipelines, the name can be anything as long as it does not contain double underscores.  \n{33}------------------------------------------------  \n![](_page_33_Picture_0.jpeg)  \nInstead of a transformer, you can specify the string \"drop\" if you want the columns to be dropped. Or you can specify \"pass through\" if you want the columns to be left untouched. By default, the remaining columns (i.e., the ones that were not listed) will be dropped, but you can set the remainder hyperparameter to any transformer (or to \"passthrough\") if you want these columns to be handled differently.  \nIf you are using Scikit-Learn 0.19 or earlier, you can use a third-party library such as sklearn-pandas, or roll out your own custom transformer to get the same function‐ ality as the ColumnTransformer. Alternatively, you can use the FeatureUnion class which can also apply different transformers and concatenate their outputs, but you cannot specify different columns for each transformer, they all apply to the whole data. It is possible to work around this limitation using a custom transformer for col‐ umn selection (see the Jupyter notebook for an example).",
      "metadata": {
        "header": "**Prepare the Data for Machine Learning Algorithms**",
        "subheader": "**Transformation Pipelines**",
        "page": "31-33",
        "chunk_id": "chk_2a37a0b7-321e-42b1-9d2b-d45be466ac97",
        "chunk_size": 714,
        "chunk_img_path": "_page_33_Picture_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_33_Picture_0.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Select and Train a Model**  \nAt last! You framed the problem, you got the data and explored it, you sampled a training set and a test set, and you wrote transformation pipelines to clean up and prepare your data for Machine Learning algorithms automatically. You are now ready to select and train a Machine Learning model.",
      "metadata": {
        "header": "**Select and Train a Model**",
        "subheader": null,
        "page": "33",
        "chunk_id": "chk_c04cf448-847f-45a1-b7ab-99f218dc93a9",
        "chunk_size": 57,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Training and Evaluating on the Training Set**  \nThe good news is that thanks to all these previous steps, things are now going to be much simpler than you might think. Let's first train a Linear Regression model, like we did in the previous chapter:  \n```\nfrom sklearn.linear_model import LinearRegression\nlin_reg = LinearRegression()\nlin_reg.fit(housing_prepared, housing_labels)\n```  \nDone! You now have a working Linear Regression model. Let's try it out on a few instances from the training set:  \n```\n>>> some_data = housing.iloc[:5]\n>>> some_labels = housing_labels.iloc[:5]\n>>> some_data_prepared = full_pipeline.transform(some_data)\n>>> print(\"Predictions:\", lin_reg.predict(some_data_prepared))\nPredictions: [ 210644.6045 317768.8069 210956.4333 59218.9888 189747.5584]\n>>> print(\"Labels:\", list(some_labels))\nLabels: [286600.0, 340600.0, 196900.0, 46300.0, 254500.0]\n```  \n{34}------------------------------------------------  \nIt works, although the predictions are not exactly accurate (e.g., the first prediction is off by close to 40%!). Let's measure this regression model's RMSE on the whole train‐ ing set using Scikit-Learn's mean\\_squared\\_error function:  \n```\n>>> from sklearn.metrics import mean_squared_error\n>>> housing_predictions = lin_reg.predict(housing_prepared)\n>>> lin_mse = mean_squared_error(housing_labels, housing_predictions)\n>>> lin_rmse = np.sqrt(lin_mse)\n>>> lin_rmse\n68628.19819848922\n```  \nOkay, this is better than nothing but clearly not a great score: most districts' median\\_housing\\_values range between \\$120,000 and \\$265,000, so a typical predic‐ tion error of \\$68,628 is not very satisfying. This is an example of a model underfitting the training data. When this happens it can mean that the features do not provide enough information to make good predictions, or that the model is not powerful enough. As we saw in the previous chapter, the main ways to fix underfitting are to select a more powerful model, to feed the training algorithm with better features, or to reduce the constraints on the model. This model is not regularized, so this rules out the last option. You could try to add more features (e.g., the log of the popula‐ tion), but first let's try a more complex model to see how it does.  \nLet's train a DecisionTreeRegressor. This is a powerful model, capable of finding complex nonlinear relationships in the data (Decision Trees are presented in more detail in Chapter 6). The code should look familiar by now:  \n```\nfrom sklearn.tree import DecisionTreeRegressor\ntree_reg = DecisionTreeRegressor()\ntree_reg.fit(housing_prepared, housing_labels)\n```  \nNow that the model is trained, let's evaluate it on the training set:  \n```\n>>> housing_predictions = tree_reg.predict(housing_prepared)\n>>> tree_mse = mean_squared_error(housing_labels, housing_predictions)\n>>> tree_rmse = np.sqrt(tree_mse)\n>>> tree_rmse\n0.0\n```  \nWait, what!? No error at all? Could this model really be absolutely perfect? Of course, it is much more likely that the model has badly overfit the data. How can you be sure? As we saw earlier, you don't want to touch the test set until you are ready to launch a model you are confident about, so you need to use part of the training set for train‐ ing, and part for model validation.",
      "metadata": {
        "header": "**Select and Train a Model**",
        "subheader": "**Training and Evaluating on the Training Set**",
        "page": "33-34",
        "chunk_id": "chk_f3b144b0-f45f-4b65-8cbe-08c5f971845a",
        "chunk_size": 465,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Better Evaluation Using Cross-Validation**  \nOne way to evaluate the Decision Tree model would be to use the train\\_test\\_split function to split the training set into a smaller training set and a validation set, then  \n{35}------------------------------------------------  \ntrain your models against the smaller training set and evaluate them against the vali‐ dation set. It's a bit of work, but nothing too difficult and it would work fairly well.  \nA great alternative is to use Scikit-Learn's *K-fold cross-validation* feature. The follow‐ ing code randomly splits the training set into 10 distinct subsets called *folds*, then it trains and evaluates the Decision Tree model 10 times, picking a different fold for evaluation every time and training on the other 9 folds. The result is an array con‐ taining the 10 evaluation scores:  \n```\nfrom sklearn.model_selection import cross_val_score\nscores = cross_val_score(tree_reg, housing_prepared, housing_labels,\nscoring=\"neg_mean_squared_error\", cv=10)\ntree_rmse_scores = np.sqrt(-scores)\n```  \n![](_page_35_Picture_3.jpeg)  \nScikit-Learn's cross-validation features expect a utility function (greater is better) rather than a cost function (lower is better), so the scoring function is actually the opposite of the MSE (i.e., a neg‐ ative value), which is why the preceding code computes -scores before calculating the square root.  \nLet's look at the results:  \n```\n>>> def display_scores(scores):\n... print(\"Scores:\", scores)\n... print(\"Mean:\", scores.mean())\n... print(\"Standard deviation:\", scores.std())\n...\n>>> display_scores(tree_rmse_scores)\nScores: [70194.33680785 66855.16363941 72432.58244769 70758.73896782\n71115.88230639 75585.14172901 70262.86139133 70273.6325285\n75366.87952553 71231.65726027]\nMean: 71407.68766037929\nStandard deviation: 2439.4345041191004\n```  \nNow the Decision Tree doesn't look as good as it did earlier. In fact, it seems to per‐ form worse than the Linear Regression model! Notice that cross-validation allows you to get not only an estimate of the performance of your model, but also a measure of how precise this estimate is (i.e., its standard deviation). The Decision Tree has a score of approximately 71,407, generally ±2,439. You would not have this information if you just used one validation set. But cross-validation comes at the cost of training the model several times, so it is not always possible.  \nLet's compute the same scores for the Linear Regression model just to be sure:  \n```\n>>> lin_scores = cross_val_score(lin_reg, housing_prepared, housing_labels,\n... scoring=\"neg_mean_squared_error\", cv=10)\n...\n>>> lin_rmse_scores = np.sqrt(-lin_scores)\n>>> display_scores(lin_rmse_scores)\n```  \n{36}------------------------------------------------  \n```\nScores: [66782.73843989 66960.118071 70347.95244419 74739.57052552\n68031.13388938 71193.84183426 64969.63056405 68281.61137997\n71552.91566558 67665.10082067]\nMean: 69052.46136345083\nStandard deviation: 2731.674001798348\n```  \nThat's right: the Decision Tree model is overfitting so badly that it performs worse than the Linear Regression model.  \nLet's try one last model now: the RandomForestRegressor. As we will see in Chap‐ ter 7, Random Forests work by training many Decision Trees on random subsets of the features, then averaging out their predictions. Building a model on top of many other models is called *Ensemble Learning*, and it is often a great way to push ML algo‐ rithms even further. We will skip most of the code since it is essentially the same as for the other models:  \n```\n>>> from sklearn.ensemble import RandomForestRegressor\n>>> forest_reg = RandomForestRegressor()\n>>> forest_reg.fit(housing_prepared, housing_labels)\n>>> [...]\n>>> forest_rmse\n18603.515021376355\n>>> display_scores(forest_rmse_scores)\nScores: [49519.80364233 47461.9115823 50029.02762854 52325.28068953\n49308.39426421 53446.37892622 48634.8036574 47585.73832311\n53490.10699751 50021.5852922 ]\nMean: 50182.303100336096\nStandard deviation: 2097.0810550985693\n```  \nWow, this is much better: Random Forests look very promising. However, note that the score on the training set is still much lower than on the validation sets, meaning that the model is still overfitting the training set. Possible solutions for overfitting are to simplify the model, constrain it (i.e., regularize it), or get a lot more training data. However, before you dive much deeper in Random Forests, you should try out many other models from various categories of Machine Learning algorithms (several Sup‐ port Vector Machines with different kernels, possibly a neural network, etc.), without spending too much time tweaking the hyperparameters. The goal is to shortlist a few (two to five) promising models.  \n{37}------------------------------------------------  \n![](_page_37_Picture_0.jpeg)  \nYou should save every model you experiment with, so you can come back easily to any model you want. Make sure you save both the hyperparameters and the trained parameters, as well as the cross-validation scores and perhaps the actual predictions as well. This will allow you to easily compare scores across model types, and compare the types of errors they make. You can easily save Scikit-Learn models by using Python's pickle module, or using sklearn.externals.joblib, which is more efficient at serializing large NumPy arrays:  \n```\nfrom sklearn.externals import joblib\njoblib.dump(my_model, \"my_model.pkl\")\n# and later...\nmy_model_loaded = joblib.load(\"my_model.pkl\")\n```",
      "metadata": {
        "header": "**Select and Train a Model**",
        "subheader": "**Better Evaluation Using Cross-Validation**",
        "page": "34-37",
        "chunk_id": "chk_518c3690-1a0d-4621-8505-0681f129e438",
        "chunk_size": 734,
        "chunk_img_path": "_page_35_Picture_3.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_35_Picture_3.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Fine-Tune Your Model**  \nLet's assume that you now have a shortlist of promising models. You now need to fine-tune them. Let's look at a few ways you can do that.",
      "metadata": {
        "header": "**Fine-Tune Your Model**",
        "subheader": null,
        "page": "37",
        "chunk_id": "chk_d9d18833-c41d-48c7-8c90-e8d74a253326",
        "chunk_size": 31,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "#### **Grid Search**  \nOne way to do that would be to fiddle with the hyperparameters manually, until you find a great combination of hyperparameter values. This would be very tedious work, and you may not have time to explore many combinations.  \nInstead you should get Scikit-Learn's GridSearchCV to search for you. All you need to do is tell it which hyperparameters you want it to experiment with, and what values to try out, and it will evaluate all the possible combinations of hyperparameter values, using cross-validation. For example, the following code searches for the best combi‐ nation of hyperparameter values for the RandomForestRegressor:  \n```\nfrom sklearn.model_selection import GridSearchCV\nparam_grid = [\n{'n_estimators': [3, 10, 30], 'max_features': [2, 4, 6, 8]},\n{'bootstrap': [False], 'n_estimators': [3, 10], 'max_features': [2, 3, 4]},\n]\nforest_reg = RandomForestRegressor()\ngrid_search = GridSearchCV(forest_reg, param_grid, cv=5,\nscoring='neg_mean_squared_error',\nreturn_train_score=True)\ngrid_search.fit(housing_prepared, housing_labels)\n```  \n{38}------------------------------------------------  \n![](_page_38_Picture_0.jpeg)  \nWhen you have no idea what value a hyperparameter should have, a simple approach is to try out consecutive powers of 10 (or a smaller number if you want a more fine-grained search, as shown in this example with the n\\_estimators hyperparameter).  \nThis param\\_grid tells Scikit-Learn to first evaluate all 3 × 4 = 12 combinations of n\\_estimators and max\\_features hyperparameter values specified in the first dict (don't worry about what these hyperparameters mean for now; they will be explained in Chapter 7), then try all 2 × 3 = 6 combinations of hyperparameter values in the second dict, but this time with the bootstrap hyperparameter set to False instead of True (which is the default value for this hyperparameter).  \nAll in all, the grid search will explore 12 + 6 = 18 combinations of RandomForestRe gressor hyperparameter values, and it will train each model five times (since we are using five-fold cross validation). In other words, all in all, there will be 18 × 5 = 90 rounds of training! It may take quite a long time, but when it is done you can get the best combination of parameters like this:  \n```\n>>> grid_search.best_params_\n{'max_features': 8, 'n_estimators': 30}\n```  \n![](_page_38_Picture_5.jpeg)  \nSince 8 and 30 are the maximum values that were evaluated, you should probably try searching again with higher values, since the score may continue to improve.  \nYou can also get the best estimator directly:  \n```\n>>> grid_search.best_estimator_\n```  \nRandomForestRegressor(bootstrap=True, criterion='mse', max\\_depth=None, max\\_features=8, max\\_leaf\\_nodes=None, min\\_impurity\\_decrease=0.0, min\\_impurity\\_split=None, min\\_samples\\_leaf=1, min\\_samples\\_split=2, min\\_weight\\_fraction\\_leaf=0.0, n\\_estimators=30, n\\_jobs=None, oob\\_score=False, random\\_state=None, verbose=0, warm\\_start=False)  \n![](_page_38_Picture_10.jpeg)  \nIf GridSearchCV is initialized with refit=True (which is the default), then once it finds the best estimator using crossvalidation, it retrains it on the whole training set. This is usually a good idea since feeding it more data will likely improve its perfor‐ mance.  \nAnd of course the evaluation scores are also available:  \n```\n>>> cvres = grid_search.cv_results_\n>>> for mean_score, params in zip(cvres[\"mean_test_score\"], cvres[\"params\"]):\n```  \n{39}------------------------------------------------  \n```\n... print(np.sqrt(-mean_score), params)\n...\n63669.05791727153 {'max_features': 2, 'n_estimators': 3}\n55627.16171305252 {'max_features': 2, 'n_estimators': 10}\n53384.57867637289 {'max_features': 2, 'n_estimators': 30}\n60965.99185930139 {'max_features': 4, 'n_estimators': 3}\n52740.98248528835 {'max_features': 4, 'n_estimators': 10}\n50377.344409590376 {'max_features': 4, 'n_estimators': 30}\n58663.84733372485 {'max_features': 6, 'n_estimators': 3}\n52006.15355973719 {'max_features': 6, 'n_estimators': 10}\n50146.465964159885 {'max_features': 6, 'n_estimators': 30}\n57869.25504027614 {'max_features': 8, 'n_estimators': 3}\n51711.09443660957 {'max_features': 8, 'n_estimators': 10}\n49682.25345942335 {'max_features': 8, 'n_estimators': 30}\n62895.088889905004 {'bootstrap': False, 'max_features': 2, 'n_estimators': 3}\n54658.14484390074 {'bootstrap': False, 'max_features': 2, 'n_estimators': 10}\n59470.399594730654 {'bootstrap': False, 'max_features': 3, 'n_estimators': 3}\n52725.01091081235 {'bootstrap': False, 'max_features': 3, 'n_estimators': 10}\n57490.612956065226 {'bootstrap': False, 'max_features': 4, 'n_estimators': 3}\n51009.51445842374 {'bootstrap': False, 'max_features': 4, 'n_estimators': 10}\n```  \nIn this example, we obtain the best solution by setting the max\\_features hyperpara‐ meter to 8, and the n\\_estimators hyperparameter to 30. The RMSE score for this combination is 49,682, which is slightly better than the score you got earlier using the default hyperparameter values (which was 50,182). Congratulations, you have suc‐ cessfully fine-tuned your best model!  \n![](_page_39_Picture_2.jpeg)  \nDon't forget that you can treat some of the data preparation steps as hyperparameters. For example, the grid search will automatically find out whether or not to add a feature you were not sure about (e.g., using the add\\_bedrooms\\_per\\_room hyperparameter of your CombinedAttributesAdder transformer). It may similarly be used to automatically find the best way to handle outliers, missing fea‐ tures, feature selection, and more.",
      "metadata": {
        "header": "**Fine-Tune Your Model**",
        "subheader": "**Grid Search**",
        "page": "37-39",
        "chunk_id": "chk_3758f6f5-fdd2-4e5f-8328-6c226ad60bb7",
        "chunk_size": 701,
        "chunk_img_path": "_page_38_Picture_0.jpeg",
        "relative_img_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\_page_38_Picture_0.jpeg",
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "## **Randomized Search**  \nThe grid search approach is fine when you are exploring relatively few combinations, like in the previous example, but when the hyperparameter *search space* is large, it is often preferable to use RandomizedSearchCV instead. This class can be used in much the same way as the GridSearchCV class, but instead of trying out all possible combi‐ nations, it evaluates a given number of random combinations by selecting a random value for each hyperparameter at every iteration. This approach has two main bene‐ fits:  \n{40}------------------------------------------------  \n- If you let the randomized search run for, say, 1,000 iterations, this approach will explore 1,000 different values for each hyperparameter (instead of just a few val‐ ues per hyperparameter with the grid search approach).\n- You have more control over the computing budget you want to allocate to hyper‐ parameter search, simply by setting the number of iterations.",
      "metadata": {
        "header": "**Fine-Tune Your Model**",
        "subheader": "**Randomized Search**",
        "page": "39-40",
        "chunk_id": "chk_5cdad5ea-866e-4f45-85e1-f44a9260ca4b",
        "chunk_size": 147,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Ensemble Methods**  \nAnother way to fine-tune your system is to try to combine the models that perform best. The group (or \"ensemble\") will often perform better than the best individual model (just like Random Forests perform better than the individual Decision Trees they rely on), especially if the individual models make very different types of errors. We will cover this topic in more detail in Chapter 7.",
      "metadata": {
        "header": "**Fine-Tune Your Model**",
        "subheader": "**Ensemble Methods**",
        "page": "40",
        "chunk_id": "chk_245be156-4b0f-4bc9-bdab-ad8e37c15ad2",
        "chunk_size": 68,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Analyze the Best Models and Their Errors**  \nYou will often gain good insights on the problem by inspecting the best models. For example, the RandomForestRegressor can indicate the relative importance of each attribute for making accurate predictions:  \n```\n>>> feature_importances = grid_search.best_estimator_.feature_importances_\n>>> feature_importances\narray([7.33442355e-02, 6.29090705e-02, 4.11437985e-02, 1.46726854e-02,\n1.41064835e-02, 1.48742809e-02, 1.42575993e-02, 3.66158981e-01,\n5.64191792e-02, 1.08792957e-01, 5.33510773e-02, 1.03114883e-02,\n1.64780994e-01, 6.02803867e-05, 1.96041560e-03, 2.85647464e-03])\n```  \nLet's display these importance scores next to their corresponding attribute names:  \n```\n>>> extra_attribs = [\"rooms_per_hhold\", \"pop_per_hhold\", \"bedrooms_per_room\"]\n>>> cat_encoder = full_pipeline.named_transformers_[\"cat\"]\n>>> cat_one_hot_attribs = list(cat_encoder.categories_[0])\n>>> attributes = num_attribs + extra_attribs + cat_one_hot_attribs\n>>> sorted(zip(feature_importances, attributes), reverse=True)\n[(0.3661589806181342, 'median_income'),\n(0.1647809935615905, 'INLAND'),\n(0.10879295677551573, 'pop_per_hhold'),\n(0.07334423551601242, 'longitude'),\n(0.0629090704826203, 'latitude'),\n(0.05641917918195401, 'rooms_per_hhold'),\n(0.05335107734767581, 'bedrooms_per_room'),\n(0.041143798478729635, 'housing_median_age'),\n(0.014874280890402767, 'population'),\n(0.014672685420543237, 'total_rooms'),\n(0.014257599323407807, 'households'),\n(0.014106483453584102, 'total_bedrooms'),\n(0.010311488326303787, '<1H OCEAN'),\n(0.002856474637320158, 'NEAR OCEAN'),\n```  \n{41}------------------------------------------------  \n```\n(0.00196041559947807, 'NEAR BAY'),\n(6.028038672736599e-05, 'ISLAND')]\n```  \nWith this information, you may want to try dropping some of the less useful features (e.g., apparently only one ocean\\_proximity category is really useful, so you could try dropping the others).  \nYou should also look at the specific errors that your system makes, then try to under‐ stand why it makes them and what could fix the problem (adding extra features or, on the contrary, getting rid of uninformative ones, cleaning up outliers, etc.).",
      "metadata": {
        "header": "**Analyze the Best Models and Their Errors**",
        "subheader": null,
        "page": "40-41",
        "chunk_id": "chk_01890575-c4ba-46cd-81de-972dda848921",
        "chunk_size": 213,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "### **Evaluate Your System on the Test Set**  \nAfter tweaking your models for a while, you eventually have a system that performs sufficiently well. Now is the time to evaluate the final model on the test set. There is nothing special about this process; just get the predictors and the labels from your test set, run your full\\_pipeline to transform the data (call transform(), *not* fit\\_transform(), you do not want to fit the test set!), and evaluate the final model on the test set:  \n```\nfinal_model = grid_search.best_estimator_\nX_test = strat_test_set.drop(\"median_house_value\", axis=1)\ny_test = strat_test_set[\"median_house_value\"].copy()\nX_test_prepared = full_pipeline.transform(X_test)\nfinal_predictions = final_model.predict(X_test_prepared)\nfinal_mse = mean_squared_error(y_test, final_predictions)\nfinal_rmse = np.sqrt(final_mse) # => evaluates to 47,730.2\n```  \nIn some cases, such a point estimate of the generalization error will not be quite enough to convince you to launch: what if it is just 0.1% better than the model cur‐ rently in production? You might want to have an idea of how precise this estimate is. For this, you can compute a 95% *confidence interval* for the generalization error using scipy.stats.t.interval():  \n```\n>>> from scipy import stats\n>>> confidence = 0.95\n>>> squared_errors = (final_predictions - y_test) ** 2\n>>> np.sqrt(stats.t.interval(confidence, len(squared_errors) - 1,\n... loc=squared_errors.mean(),\n... scale=stats.sem(squared_errors)))\n...\narray([45685.10470776, 49691.25001878])\n```  \nThe performance will usually be slightly worse than what you measured using crossvalidation if you did a lot of hyperparameter tuning (because your system ends up fine-tuned to perform well on the validation data, and will likely not perform as well  \n{42}------------------------------------------------  \non unknown datasets). It is not the case in this example, but when this happens you must resist the temptation to tweak the hyperparameters to make the numbers look good on the test set; the improvements would be unlikely to generalize to new data.  \nNow comes the project prelaunch phase: you need to present your solution (high‐ lighting what you have learned, what worked and what did not, what assumptions were made, and what your system's limitations are), document everything, and create nice presentations with clear visualizations and easy-to-remember statements (e.g., \"the median income is the number one predictor of housing prices\"). In this Califor‐ nia housing example, the final performance of the system is not better than the experts', but it may still be a good idea to launch it, especially if this frees up some time for the experts so they can work on more interesting and productive tasks.",
      "metadata": {
        "header": "**Analyze the Best Models and Their Errors**",
        "subheader": "**Evaluate Your System on the Test Set**",
        "page": "41-42",
        "chunk_id": "chk_12005cd5-b534-4e79-bab0-8eab71318e1a",
        "chunk_size": 401,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Launch, Monitor, and Maintain Your System**  \nPerfect, you got approval to launch! You need to get your solution ready for produc‐ tion, in particular by plugging the production input data sources into your system and writing tests.  \nYou also need to write monitoring code to check your system's live performance at regular intervals and trigger alerts when it drops. This is important to catch not only sudden breakage, but also performance degradation. This is quite common because models tend to \"rot\" as data evolves over time, unless the models are regularly trained on fresh data.  \nEvaluating your system's performance will require sampling the system's predictions and evaluating them. This will generally require a human analysis. These analysts may be field experts, or workers on a crowdsourcing platform (such as Amazon Mechanical Turk or CrowdFlower). Either way, you need to plug the human evalua‐ tion pipeline into your system.  \nYou should also make sure you evaluate the system's input data quality. Sometimes performance will degrade slightly because of a poor quality signal (e.g., a malfunc‐ tioning sensor sending random values, or another team's output becoming stale), but it may take a while before your system's performance degrades enough to trigger an alert. If you monitor your system's inputs, you may catch this earlier. Monitoring the inputs is particularly important for online learning systems.  \nFinally, you will generally want to train your models on a regular basis using fresh data. You should automate this process as much as possible. If you don't, you are very likely to refresh your model only every six months (at best), and your system's perfor‐ mance may fluctuate severely over time. If your system is an online learning system, you should make sure you save snapshots of its state at regular intervals so you can easily roll back to a previously working state.  \n{43}------------------------------------------------",
      "metadata": {
        "header": "**Launch, Monitor, and Maintain Your System**",
        "subheader": null,
        "page": "42-43",
        "chunk_id": "chk_333dd300-ba52-4661-bdc4-2679425f2903",
        "chunk_size": 308,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Try It Out!**  \nHopefully this chapter gave you a good idea of what a Machine Learning project looks like, and showed you some of the tools you can use to train a great system. As you can see, much of the work is in the data preparation step, building monitoring tools, setting up human evaluation pipelines, and automating regular model training. The Machine Learning algorithms are also important, of course, but it is probably preferable to be comfortable with the overall process and know three or four algo‐ rithms well rather than to spend all your time exploring advanced algorithms and not enough time on the overall process.  \nSo, if you have not already done so, now is a good time to pick up a laptop, select a dataset that you are interested in, and try to go through the whole process from A to Z. A good place to start is on a competition website such as *<http://kaggle.com/>*: you will have a dataset to play with, a clear goal, and people to share the experience with.",
      "metadata": {
        "header": "**Try It Out!**",
        "subheader": null,
        "page": "43",
        "chunk_id": "chk_9e9c21b4-922d-4bed-96f9-32ce7e54cd52",
        "chunk_size": 178,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    },
    {
      "text": "# **Exercises**  \nUsing this chapter's housing dataset:  \n- 1. Try a Support Vector Machine regressor (sklearn.svm.SVR), with various hyper‐ parameters such as kernel=\"linear\" (with various values for the C hyperpara‐ meter) or kernel=\"rbf\" (with various values for the C and gamma hyperparameters). Don't worry about what these hyperparameters mean for now. How does the best SVR predictor perform?\n- 2. Try replacing GridSearchCV with RandomizedSearchCV.\n- 3. Try adding a transformer in the preparation pipeline to select only the most important attributes.\n- 4. Try creating a single pipeline that does the full data preparation plus the final prediction.\n- 5. Automatically explore some preparation options using GridSearchCV.  \nSolutions to these exercises are available in the online Jupyter notebooks at *[https://](https://github.com/ageron/handson-ml2) [github.com/ageron/handson-ml2](https://github.com/ageron/handson-ml2)*.",
      "metadata": {
        "header": "**Exercises**",
        "subheader": null,
        "page": "43",
        "chunk_id": "chk_f2a32094-f02c-465e-85eb-e34d2cbf2a65",
        "chunk_size": 122,
        "chunk_img_path": null,
        "relative_img_path": null,
        "file_id": "fi_a27849b0-a326-4fcb-9792-039c9364defa",
        "file_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2\\oreilly-p2.md",
        "folder_path": "C:\\Users\\Dell\\OneDrive - OnPoint Insights LLC\\Documents\\workspace\\blue_carbon\\utils\\data\\output\\oreilly-p2",
        "source": "langchain_markdown_splitter"
      }
    }
  ]
}